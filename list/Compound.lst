C51 COMPILER V9.54   COMPOUND                                                              12/05/2024 11:39:01 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE COMPOUND
OBJECT MODULE PLACED IN .\obj\Compound.obj
COMPILER INVOKED BY: D:\installations\keil_c51\C51\BIN\C51.EXE Compound.C LARGE OPTIMIZE(6,SPEED) BROWSE INCDIR(.\hal_dr
                    -iver) DEBUG OBJECTEXTEND PRINT(.\list\Compound.lst) TABS(2) OBJECT(.\obj\Compound.obj)

line level    source

   1          /********************************** (C) COPYRIGHT ******************************
   2          * File Name          :Compound_Dev.C                        
   3          * Author             : WCH                                                      
   4          * Version            : V1.2                                                     
   5          * Date               : 2017/02/24                                               
   6          * Description        : A demo for USB compound device created by CH554, support 
   7                       keyboard , and HID-compliant device.                     
   8          ********************************************************************************/
   9          
  10          #include  ".\Public\CH554.H"
  11          #include  ".\Public\DEBUG.H"
  12          #include  "compound.h"
  13          #include  "key.h"
  14          
  15          #include  <stdio.h>
  16          #include  <stdlib.h>
  17          #include  <string.h>
  18          
  19          
  20          #define   THIS_ENDP0_SIZE         DEFAULT_ENDP0_SIZE
  21          #define   BUFFER_SIZE       64
  22          #define   DUAL_BUFFER_SIZE    128
  23          #define   UsbSetupBuf         ((PUSB_SETUP_REQ)Ep0Buffer)
  24          #define   L_WIN           0X08
  25          #define   L_ALT           0X04
  26          #define   L_SHIFT         0X02
  27          #define   L_CTL         0X01
  28          #define   R_WIN           0X80
  29          #define   R_ALT           0X40
  30          #define   R_SHIFT         0X20
  31          #define   R_CTL         0X10
  32          #define   SPACE         0X2C
  33          #define   ENTER         0X28
  34          
  35          #define MOUSE 0
  36          
  37          #pragma  NOAREGS
  38          
  39          UINT8X    Ep0Buffer[THIS_ENDP0_SIZE]  _at_ 0x0000;                  // Endpoint 0, buffer OUT/OUT，the address must
             - be even.
  40          UINT8X    Ep1Buffer[BUFFER_SIZE]    _at_ 0x000A;                  // Endpoint 1, buffer IN，the address must be even
             -.
  41          UINT8X    Ep2Buffer[DUAL_BUFFER_SIZE] _at_ 0x0050;                  // Endpoint 2, buffer OUT[64]+IN[64]，the addre
             -ss must be even.
  42          
  43          
  44          /**************************** Global variable ********************************/ 
  45          UINT8   volatile  SetupReq, SetupLen, UsbConfig;
  46          UINT8 volatile  EnumOK, FLAG;
  47          PUINT8    pDescr;                                                                 // USB enumerate complete
             - flag.
  48          USB_SETUP_REQ             SetupReqBuf;                                    // A buffer for Setup package.
  49          
  50          char code sPath[] = "`  C:\\HID_RECV.EXE   \r   ";                    // The path for the software. SPACE for delay
C51 COMPILER V9.54   COMPOUND                                                              12/05/2024 11:39:01 PAGE 2   

  51          char *pStr = sPath;
  52          
  53          UINT8 HIDCom[64] = {0};                       
  54          UINT8 HIDKey[8] = {0};
  55          
  56          static UINT8 compound_received_data[BUFFER_SIZE] = {0};                   // 存储从PC中接收的数据
  57          static UINT8 compound_response_data[BUFFER_SIZE] = {0};
  58          volatile UINT8 g_data_ready;
  59          volatile UINT8 g_data_len;
  60          #define PACKET_HEADER         0xAA
  61          #define USB_OP_HEARTBEAT      0x10
  62          #define USB_OP_WL_LEARNMATCH    0x1F
  63          #define USB_OP_WL_CLEANMATCH    0X20
  64          
  65          
  66          #define VERSION_STR         "1.0.0"
  67          #define DEVICE_VID_L     0x31    // VID低字节
  68          #define DEVICE_VID_H     0x51    // VID高字节
  69          #define DEVICE_PID_L     0x07    // PID低字节
  70          #define DEVICE_PID_H     0x20    // PID高字节
  71          static UINT8 first_hb_flag = 0;
  72          extern void soft_reset(void);
  73          extern void timer0_register_cb(void (*cb)(void));  // 声明timer注册函数
  74          extern void led_flash_handler(void);               // 声明回调函数
  75          // 1. 先声明函数原型
  76          void compound_process_recv_data(UINT8 len);
  77          UINT8 usb_check_heartbeat_packet(UINT8 *compound_data, UINT8 len);
  78          volatile UINT8 g_compound_heartbeat_flag = 0;
  79          volatile UINT8 g_compound_heartbeat_timer = 0;
  80          
  81          // 定义学习状态
  82          
  83          volatile learnmatch_state_t learnmatch_state = LEARNMATCH_STATE_IDLE;
  84          volatile UINT16 g_learnmatch_timer = 0; // 计时器，单位为10ms
  85          volatile cleanmatch_state_t cleanmatch_state = CLEANMATCH_STATE_IDLE;
  86          volatile UINT16 g_cleanmatch_timer = 0; // 计时器，单位为10ms
  87          
  88          sbit LED1 = P3^2;
  89          
  90          
  91          /**************************** Device Descriptor *************************************/
  92          UINT8C DevDesc[18] = {                                // Device Descriptor
  93            0x12,0x01,
  94            0x10,0x01,
  95            0x00,0x00,
  96            0x00,0x08,                      
  97            0x31,0x51,                                    // Vendor ID   |  VID =  0X5131///413c
  98            0x07,0x20,                                    // Product ID  |  PID = 0X2007 /// 2105
  99          //  0x00,0x01,
 100          //  0x05,0x21,
 101            0x00,0x11,                                    // bcdDevice    
 102            0x00,0x00,
 103            0x00,0x01
 104          };
 105          /**************************** HID Report Descriptor *********************************/
 106          UINT8C KeyRepDesc[65] =                               // Report Descriptor, DELL Keyboard
 107          {
 108            0x05, 0x01,     // Usage page Generatic Desktop
 109            0x09, 0x06,     // Usage keyboard
 110            0xa1, 0x01,     // Collation Application
 111            0x05, 0x07,     // Usafe page (key code)
 112            0x19, 0xe0,     // Usage Min ( E0 -->  L_CTL)
C51 COMPILER V9.54   COMPOUND                                                              12/05/2024 11:39:01 PAGE 3   

 113            0x29, 0xe7,     // Usage MAX ( E7 --> R_GUI )
 114            0x15, 0x00,     // Logical min
 115            0x25, 0x01,     // Logical max
 116            0x95, 0x08,     // Report count ( 8 )
 117            0x75, 0x01,     // Report size  ( 1 )
 118            0x81, 0x02,     // Input ( Data, Variable, Absolute )
 119            0x95, 0x08,     // Report count ( 8 )
 120            0x75, 0x01,     // Report size  ( 1 )
 121            0x81, 0x01,     // Input ( const )
 122            0x05, 0x08,     // Usage page( LED )
 123            0x19, 0x01,     // Usage min ( 1 )
 124            0x29, 0x03,     // Usage max ( 3 )
 125            0x95, 0x03,     // Report count ( 3 )
 126            0x75, 0x01,     // Report size ( 1 )
 127            0x91, 0x02,     // Output ( Data, Variable, Absolute )
 128            0x95, 0x01,     // Report count ( 1 )
 129            0x75, 0x05,     // Report size ( 5 )
 130            0x91, 0x01,     // Output ( const )
 131            0x05, 0x07,     // Usage page ( key code )
 132            0x19, 0x00,     // Usage min ( 0H )
 133            0x2a, 0xff, 0x00, // Usage max ( FFH )
 134            0x15, 0x00,     // Logical min ( 0H )
 135            0x26, 0xff, 0x00, // Logical max ( FFH )
 136            0x95, 0x06,     // Report count ( 6 )
 137            0x75, 0x08,     // Report size ( 8 )
 138            0x81, 0x00,     // Input ( Data, Array, Absolute )
 139            0xc0        // End collection
 140          };
 141          
 142          UINT8C ComRepDesc[34] =                               // Report Descriptor, Composite device
 143          {
 144            0x06, 0x00, 0xff,   // Usage page Vendor defined
 145            0x09, 0x01,     // Usage keyboard
 146            0xa1, 0x01,     // Collation Application
 147            0x09, 0x02,     // Mouse
 148            0x15, 0x00,     // Logical min ( 0H )
 149            0x26, 0x00, 0xff, // Logical max ( FFH )
 150            0x75, 0x08,     // Report size ( 08H )
 151            0x95, 0x40,     // Report count ( 40H )
 152            0x81, 0x06,     // Input ( Data, Relative, Wrap )
 153            0x09, 0x02,     // Mouse
 154            0x15, 0x00,     // Logical min ( 0H )
 155            0x26, 0x00, 0xff, // Logical max ( FFH )
 156            0x75, 0x08,     // Report size ( 08H )
 157            0x95, 0x40,     // Report count ( 40H )
 158            0x91, 0x06,     // Output ( Data, Relative, Wrap )
 159            0xc0,
 160          };
 161          
 162          
 163          UINT8C CfgDesc[9+9+9+7+9+9+7+7] =
 164          {
 165              0x09,0x02,0x42,0x00,0x02,0x01,0x00,0xA0,0x32,                         // Configure Descriptor
 166                 
 167          //  0x09,0x02,0x22,0x00,0x01,0x01,0x00,0xA0,0x32,
 168            0x09,0x04,0x00,0x00,0x01,0x03,0x01,0x01,0x00,                         // Interface Descriptor, keyboard
 169              0x09,0x21,0x11,0x01,0x00,0x01,0x22,sizeof(KeyRepDesc),0x00,                 // HID Descriptor
 170              0x07,0x05,0x81,0x03,0x08,0x00,0x0a,                                   // Endpoint Descriptor, 50ms
 171          
 172          //   0x09,0x02,0x29,0x00,0x01,0x01,0x00,0xA0,0x32,                        // Configure Descriptor 
 173          //    0x09,0x04,0x00,0x00,0x02,0x03,0x00,0x00,0x00,                         // Interface Descriptor, Composite d
             -evice， 2 EPs
C51 COMPILER V9.54   COMPOUND                                                              12/05/2024 11:39:01 PAGE 4   

 174            0x09,0x04,0x01,0x00,0x02,0x03,0x00,0x00,0x00,                         // Interface Descriptor, Composite device
             -， 2 EPs
 175              0x09,0x21,0x10,0x01,0x21,0x01,0X22,sizeof(ComRepDesc),0x00,                 // HID Descriptor
 176              0x07,0x05,0x82,0x03,0x40,0x00,0x32,                                   // Endpoint Descriptor, 10ms, IN
 177            0x07,0x05,0x02,0x03,0x40,0x00,0x0a                        // Endpoint Descriptor, 10ms, OUT
 178          };
 179          
 180          void compound_process_recv_data(UINT8 len);
 181          
 182          /*******************************************************************************
 183          * Function Name  : USBDeviceInit()
 184          * Description    : Configure USB mode ，USB device init configure.Configure tie Endpoint, compound device,
             - 
 185                             Endpoint 0 control trans, Endpoint 1/2 interrupt(IN).
 186          * Input          : None
 187          * Output         : None
 188          * Return         : None
 189          *******************************************************************************/
 190          void USBDeviceInit()
 191          {
 192   1          IE_USB = 0;
 193   1          USB_CTRL = 0x00;                                                           // Device mode
 194   1        
 195   1          UEP1_DMA = Ep1Buffer;                                                      // Endpoint 1 uploard addre
             -ss
 196   1          UEP0_DMA = Ep0Buffer;                                                      // Endpoint 0 trans address
 197   1          UEP2_DMA = Ep2Buffer;                                                      // Endpoint 2 uploard addre
             -ss  
 198   1          UEP4_1_MOD = UEP4_1_MOD | bUEP1_TX_EN & ~(bUEP1_RX_EN | bUEP1_BUF_MOD | bUEP4_RX_EN | bUEP4_TX_EN); //
             - Endpoint 1 sigle 64 byte send buffer, Endpoint 4 disable
 199   1          UEP1_CTRL = bUEP_AUTO_TOG | UEP_T_RES_NAK;                                 // Endpoint 1 auto Toggle f
             -lag, In translation return NAK
 200   1          UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_NAK;                                 // Endpoint 0 OUT trans ret
             -urn ACK, IN trans return NAK    
 201   1      
 202   1          UEP2_3_MOD = UEP2_3_MOD | bUEP2_TX_EN | bUEP2_RX_EN & ~bUEP2_BUF_MOD;      // Endpoint 2 sigle 64 byte
             - send buffer OUT[64]+IN[64] (OUT first)
 203   1          UEP2_CTRL = bUEP_AUTO_TOG | UEP_T_RES_NAK;                                 // Endpoint 2 auto Toggle f
             -lag, IN trans return NAK
 204   1          
 205   1          USB_DEV_AD = 0x00;                                                         // Initial the device addres
             -s
 206   1          UDEV_CTRL = bUD_PD_DIS;                                                    // Disable DM/PM PULL_DOWN.
 207   1          USB_CTRL = bUC_DEV_PU_EN | bUC_INT_BUSY | bUC_DMA_EN;                      // Enable inter PULL_UP. Aut
             -o return NAK, during interrupt routing, if the interrupt flag.
 208   1          UDEV_CTRL |= bUD_PORT_EN;                                                  // Enable USB port.
 209   1          USB_INT_FG = 0xFF;                                                         // Clear interrupt flag.
 210   1          USB_INT_EN = bUIE_SUSPEND | bUIE_TRANSFER | bUIE_BUS_RST;                  // Enable USB interrupt
 211   1          IE_USB = 1;                                                                // Enable USB interrupt
 212   1      }
 213          
 214          /*******************************************************************************
 215          * Function Name  : Enp1IntIn()
 216          * Description    : USB Device mode Endpoint 1 upload data, Interrupt mode
 217          * Input          : None
 218          * Output         : None
 219          * Return         : None
 220          *******************************************************************************/
 221          static void Enp1IntIn( void )
 222          {     
 223   1          memcpy( Ep1Buffer, HIDKey, sizeof(HIDKey));                                   // Upload data
 224   1          UEP1_T_LEN = sizeof(HIDKey);                                                  // Upload length
C51 COMPILER V9.54   COMPOUND                                                              12/05/2024 11:39:01 PAGE 5   

 225   1          UEP1_CTRL = UEP1_CTRL & ~ MASK_UEP_T_RES | UEP_T_RES_ACK;                     // Return ACK
 226   1          while(( UEP1_CTRL & MASK_UEP_T_RES ) == UEP_T_RES_ACK);                       // Waiting upload complete
             -, avoid overwriting 
 227   1      }
 228          /*******************************************************************************
 229          * Function Name  : Enp2IntIn()
 230          * Description    : USB Device mode Endpoint 2 upload data, Interrupt mode 
 231          * Input          : None
 232          * Output         : None
 233          * Return         : None
 234          *******************************************************************************/
 235          static void Enp2IntIn( void )
 236          { 
 237   1          memcpy( &Ep2Buffer[64], HIDCom, sizeof(HIDCom) );                               // Upload data
 238   1          UEP2_T_LEN = sizeof(HIDCom);                                                  // Upload length
 239   1          UEP2_CTRL = UEP2_CTRL & ~ MASK_UEP_T_RES | UEP_T_RES_ACK;                     // Return ACK
 240   1          while(( UEP2_CTRL & MASK_UEP_T_RES ) == UEP_T_RES_ACK);                       // Waiting upload complete
             -, avoid overwriting 
 241   1      }     
 242          
 243          /*******************************************************************************
 244          * Function Name  : DeviceInterrupt()
 245          * Description    : CH554USB ISR
 246          *******************************************************************************/
 247          void DeviceInterrupt( void ) interrupt INT_NO_USB using 1                           //USB ISR, Using registe
             -r 1
 248          {
 249   1          UINT8 len;      
 250   1        
 251   1          if(UIF_TRANSFER)                                                                //USB trans flag
 252   1          { 
 253   2          switch (USB_INT_ST & (MASK_UIS_TOKEN | MASK_UIS_ENDP) )     
 254   2              {     
 255   3              case UIS_TOKEN_IN | 2:                                                      // Endpoint 2 upload
 256   3            UEP2_T_LEN = 0;                                                         // Reset length
 257   3                  UEP2_CTRL = UEP2_CTRL & ~ MASK_UEP_T_RES | UEP_T_RES_NAK;               // Default return NAK
 258   3                  break;                                                                         
 259   3           case UIS_TOKEN_OUT | 2:
 260   3           {
 261   4            len = USB_RX_LEN;
 262   4            if (len > BUFFER_SIZE)
 263   4            {
 264   5              len = BUFFER_SIZE;
 265   5            }
 266   4      
 267   4            memcpy(compound_received_data, Ep2Buffer, len);
 268   4            g_data_len = len;
 269   4            g_data_ready = 1;
 270   4            // compound_process_recv_data(len);
 271   4            
 272   4            UEP2_CTRL = UEP2_CTRL & ~ MASK_UEP_R_RES | UEP_R_RES_ACK;               // Default return ACK
 273   4            
 274   4            break;
 275   4            
 276   4                                                                // Eendpoint 2 download 
 277   4                  // UEP2_CTRL = UEP2_CTRL & ~ MASK_UEP_R_RES | UEP_T_RES_NAK;              // Default return NAK
 278   4                  // break;
 279   4           }                                                                         
 280   3              case UIS_TOKEN_IN | 1:                                                      // Endpoint 1 upload
 281   3            UEP1_T_LEN = 0;                                                         // Reset length
 282   3                  UEP1_CTRL = UEP1_CTRL & ~ MASK_UEP_T_RES | UEP_T_RES_NAK;               // Default return NAK
 283   3                  FLAG = 1;                                                               // Upload complete flag
C51 COMPILER V9.54   COMPOUND                                                              12/05/2024 11:39:01 PAGE 6   

 284   3                  break;                                                                       
 285   3              case UIS_TOKEN_SETUP | 0:                                                   // SETUP packet
 286   3                  len = USB_RX_LEN;
 287   3                  if( len == (sizeof(USB_SETUP_REQ)) )
 288   3                  {
 289   4                      SetupLen = UsbSetupBuf->wLengthL;
 290   4                      if(UsbSetupBuf->wLengthH || SetupLen > 0x7F )
 291   4                      {
 292   5                          SetupLen = 0x7F;                            // Total length less than 0X7F
 293   5                      }
 294   4                      len = 0;                                                            // Default length is 0
 295   4                      if( (UsbSetupBuf->bRequestType & USB_REQ_TYP_MASK) != USB_REQ_TYP_STANDARD )
 296   4                      {
 297   5                if( (UsbSetupBuf->bRequestType == 0x21)&&(UsbSetupBuf->bRequest == HID_SET_REPORT) )
 298   5                {     
 299   6                  EnumOK = 1;                           // Class require, SET REPORT, indicate the enumerate complete             
 300   6      #if DE_PRINTF
                printf( "Init ok \r\n" );
              #endif            
 303   6                }
 304   5                if( (UsbSetupBuf->bRequestType == 0x21)&&(UsbSetupBuf->bRequest == HID_SET_IDLE) )
 305   5                {         
 306   6                  UEP0_T_LEN = 0;                                                 //Status stage complete, upload 0 da
             -ta packet, end the control trans
 307   6        //          UEP0_CTRL = bUEP_R_TOG | bUEP_T_TOG | UEP_R_RES_STALL | UEP_T_RES_STALL;
 308   6                }
 309   5                          len = 0;                                                      // Fail
 310   5                      }
 311   4              else{
 312   5                                                  // Deal with the standard require
 313   5                SetupReq = UsbSetupBuf->bRequest;
 314   5                switch( SetupReq )                                                  // Require code
 315   5                {
 316   6                case USB_GET_DESCRIPTOR:
 317   6                  switch( UsbSetupBuf->wValueH )
 318   6                  {
 319   7                  case 1:                                                         // Device descriptor          
 320   7                    pDescr = DevDesc;                                           // Write device descriptor to buffer
 321   7                    len = sizeof( DevDesc );  
 322   7                    break;  
 323   7                  case 2:                                                         // Configuration descriptor         
 324   7                    pDescr = CfgDesc;                                           // Write configuration descriptor to buf
             -fer
 325   7                    len = sizeof( CfgDesc );  
 326   7                    break;  
 327   7                  case 0x22:                                                      // HID report descriptor            
 328   7                    if( UsbSetupBuf->wIndexL == 0 )                             // Interface index 0 HID report --> keyb
             -oard
 329   7                    {           
 330   8                      pDescr = KeyRepDesc;                                    // Write to buffer
 331   8                      len = sizeof( KeyRepDesc ); 
 332   8                    } 
 333   7                    else  
 334   7                      if( UsbSetupBuf->wIndexL == 1 )                         // Interface index 1 HID report --> Composi
             -te device
 335   7                      {               
 336   8                        pDescr = ComRepDesc;                                // Write to buffer
 337   8                        len = sizeof( ComRepDesc );
 338   8                      }
 339   7                      else
 340   7                      {
 341   8                        len = 0xff;                                         // Add interface index, if required
C51 COMPILER V9.54   COMPOUND                                                              12/05/2024 11:39:01 PAGE 7   

 342   8                      }
 343   7      //              if( UsbSetupBuf->wIndexL == 0 )                         // Interface index 1 HID report --> Compos
             -ite device
 344   7      //              {               
 345   7      //                pDescr = ComRepDesc;                                // Write to buffer
 346   7      //                len = sizeof( ComRepDesc );
 347   7      //              }
 348   7      //              else
 349   7      //              {
 350   7      //                len = 0xff;                                         // Add interface index, if required
 351   7      //              }
 352   7                      break;
 353   7                  default:
 354   7                    len = 0xff;                                                 // Length equal 0 if code error
 355   7                    break;  
 356   7                  } 
 357   6                  if ( len == 0xff ){ 
 358   7                    break;                                                      // Error code, jump out the swith senten
             -ce
 359   7                  }                     
 360   6                  if ( SetupLen > len ){  
 361   7                    SetupLen = len;                                             // Limit the total length 
 362   7                  } 
 363   6                  len = SetupLen >= 8 ? 8 : SetupLen;                             // Upload this length
 364   6                  memcpy( Ep0Buffer, pDescr, len );                               // Upload data
 365   6                  SetupLen -= len;  
 366   6                  pDescr += len;  
 367   6                  break;  
 368   6                    
 369   6                case USB_SET_ADDRESS: 
 370   6                  SetupLen = UsbSetupBuf->wValueL;                                // Save the device address          
 371   6                  break;
 372   6                case USB_GET_CONFIGURATION:
 373   6          
 374   6                  Ep0Buffer[0] = UsbConfig;
 375   6                  if ( SetupLen >= 1 )
 376   6                  {
 377   7                    len = 1;
 378   7                  }         
 379   6                  break;
 380   6                case USB_SET_CONFIGURATION:
 381   6            
 382   6                  UsbConfig = UsbSetupBuf->wValueL;       
 383   6                  break;
 384   6                case 0x0A:
 385   6                  break;
 386   6                case USB_CLEAR_FEATURE:                                             //Clear Feature
 387   6            
 388   6                  if ( (UsbSetupBuf->bRequestType & USB_REQ_RECIP_MASK) == USB_REQ_RECIP_ENDP ) 
 389   6                  {
 390   7                     switch( UsbSetupBuf->wIndexL )
 391   7                     {
 392   8                      case 0x82:
 393   8                         UEP2_CTRL = UEP2_CTRL & ~ (bUEP_T_TOG | MASK_UEP_T_RES) | UEP_T_RES_NAK;
 394   8                         break;
 395   8                      case 0x81:
 396   8                         UEP1_CTRL = UEP1_CTRL & ~ (bUEP_T_TOG | MASK_UEP_T_RES) | UEP_T_RES_NAK;
 397   8                         break;
 398   8                      case 0x01:
 399   8                         UEP1_CTRL = UEP1_CTRL & ~ (bUEP_R_TOG | MASK_UEP_R_RES) | UEP_R_RES_ACK;
 400   8                         break;
 401   8                      default:
C51 COMPILER V9.54   COMPOUND                                                              12/05/2024 11:39:01 PAGE 8   

 402   8                         len = 0xFF;                                          // Error endpoint
 403   8                         break;
 404   8                    }
 405   7                   }
 406   6                  else
 407   6                  {
 408   7                    len = 0xFF;                                                 // Deal with the error endpoint
 409   7                  }
 410   6                  break;
 411   6                case USB_SET_FEATURE:                                             // Set Feature          
 412   6                  if( (UsbSetupBuf->bRequestType & 0x1F) == 0x00 )               
 413   6                  {
 414   7                    if( ( ((UINT16)UsbSetupBuf->wValueH << 8) | UsbSetupBuf->wValueL ) == 0x01 )
 415   7                    {
 416   8                      if( CfgDesc[ 7 ] & 0x20 )
 417   8                      {
 418   9                         /* Awake the device */
 419   9                      }
 420   8                      else
 421   8                      {
 422   9                        len = 0xFF;                                         // Error routing
 423   9                      }
 424   8                    }
 425   7                    else
 426   7                    {
 427   8                      len = 0xFF;                                             // Error routing
 428   8                    }
 429   7                  }
 430   6                  else 
 431   6                    if( (UsbSetupBuf->bRequestType & 0x1F) == 0x02 )            // Set endpoint
 432   6                    {
 433   7                      if( ( ((UINT16)UsbSetupBuf->wValueH << 8) | UsbSetupBuf->wValueL ) == 0x00 )
 434   7                      {
 435   8                        switch( ((UINT16)UsbSetupBuf->wIndexH << 8) | UsbSetupBuf->wIndexL )
 436   8                        {
 437   9                          case 0x82:
 438   9                            UEP2_CTRL = UEP2_CTRL & (~bUEP_T_TOG) | UEP_T_RES_STALL;/* Endpoint 2 IN STALL */
 439   9                            //timer0_register_cb(led_flash_handler);
 440   9                           
 441   9                            break;
 442   9      
 443   9                          case 0x02:
 444   9                            UEP2_CTRL = UEP2_CTRL & (~bUEP_R_TOG) | UEP_R_RES_STALL;/* Endpoint 2 OUT STALL */
 445   9                            //timer0_register_cb(led_flash_handler);
 446   9                           
 447   9                            break;
 448   9      
 449   9                          case 0x81:
 450   9                            UEP1_CTRL = UEP1_CTRL & (~bUEP_T_TOG) | UEP_T_RES_STALL;/* Endpoint 1 IN STALL */
 451   9                            //timer0_register_cb(led_flash_handler);
 452   9                           
 453   9                            break;
 454   9      
 455   9                          default:
 456   9                            len = 0xFF;                                     // Error routing
 457   9                            break;
 458   9                        }
 459   8                      }
 460   7                      else
 461   7                      {
 462   8                        len = 0xFF;                                         // Error routing
 463   8                      }
C51 COMPILER V9.54   COMPOUND                                                              12/05/2024 11:39:01 PAGE 9   

 464   7                    }
 465   6                    else
 466   6                    {
 467   7                      len = 0xFF;                                             // Error routing
 468   7                    }
 469   6                    break;
 470   6                case USB_GET_STATUS:                          // Get status
 471   6                   Ep0Buffer[0] = 0x00;
 472   6                   Ep0Buffer[1] = 0x00;
 473   6                   if ( SetupLen >= 2 )
 474   6                   {
 475   7                    len = 2;
 476   7                   }
 477   6                   else
 478   6                   {
 479   7                    len = SetupLen;
 480   7                   }
 481   6                   break;
 482   6                default:
 483   6                  len = 0xff;                                                       // Error routing
 484   6                  break;
 485   6                }
 486   5              }
 487   4                  }
 488   3                  else
 489   3                  {
 490   4                      len = 0xff;                                                             //Packet length erro
             -r
 491   4                  }
 492   3                  if(len == 0xff)
 493   3                  {
 494   4                      SetupReq = 0xFF;
 495   4       //               UEP0_CTRL = bUEP_R_TOG | bUEP_T_TOG | UEP_R_RES_STALL | UEP_T_RES_STALL;  // Control endp
             -oint should not return STALL, 
 496   4                                                    // if Send STALL, that means the device has no ability to communicate with the host
 497   4                  }
 498   3                  else if(len <= 8)                                                           // Upload the data o
             -r return the 0 data packet
 499   3                  {   
 500   4                      UEP0_T_LEN = len;   
 501   4                      UEP0_CTRL = bUEP_R_TOG | bUEP_T_TOG | UEP_R_RES_ACK | UEP_T_RES_ACK;    // Default data pack
             -et is DATA1, and return ACK
 502   4                  }   
 503   3                  else    
 504   3                  {   
 505   4                      UEP0_T_LEN = 0;                               // Upload 0 data packet, incase the host go to status stag
             -e ahead, and get fault code
 506   4                      UEP0_CTRL = bUEP_R_TOG | bUEP_T_TOG | UEP_R_RES_ACK | UEP_T_RES_ACK;    // Default data pack
             -et is DATA1, and return ACK
 507   4                  }   
 508   3                  break;    
 509   3              case UIS_TOKEN_IN | 0:                                                          // Endpoint 0 IN
 510   3                  switch(SetupReq)
 511   3                  {
 512   4                  case USB_GET_DESCRIPTOR:
 513   4                      len = SetupLen >= 8 ? 8 : SetupLen;                                     // Current length
 514   4                      memcpy( Ep0Buffer, pDescr, len );                                       // Upload the data
 515   4                      SetupLen -= len;
 516   4                      pDescr += len;
 517   4                      UEP0_T_LEN = len;
 518   4                      UEP0_CTRL ^= bUEP_T_TOG;                                                //Toggle Sysc flag 
 519   4                      break;
C51 COMPILER V9.54   COMPOUND                                                              12/05/2024 11:39:01 PAGE 10  

 520   4                  case USB_SET_ADDRESS:
 521   4                      USB_DEV_AD = USB_DEV_AD & bUDA_GP_BIT | SetupLen;
 522   4                      UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_NAK;
 523   4                      break;
 524   4                  default:
 525   4      //                UEP0_T_LEN = 0;                                                         //Status stage com
             -plete, upload 0 data packet, end the control trans
 526   4      //                UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_NAK;    
 527   4                      break;
 528   4                  }
 529   3            if(len == 0xff)
 530   3            {
 531   4              UEP0_T_LEN = 0;                                                         //Status stage complete, upload 
             -0 data packet, end the control trans
 532   4                      UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_NAK;    
 533   4            }
 534   3                  break;
 535   3              case UIS_TOKEN_OUT | 0:                               // Endpoint 0 OUT
 536   3                  len = USB_RX_LEN;
 537   3                  if( SetupReq == 0x09 )
 538   3                  {
 539   4                      if( Ep0Buffer[0] )
 540   4                      {
 541   5      #if DE_PRINTF
                                  printf("Light on Num Lock LED!\n");
              #endif
 544   5                      }
 545   4                      else if( Ep0Buffer[0] == 0)
 546   4                      {
 547   5      #if DE_PRINTF
                                  printf("Light off Num Lock LED!\n");
              #endif
 550   5                      }
 551   4                  }
 552   3                  UEP0_T_LEN = 0;                                 // Upload 0 data packet, incase the host go to status stage a
             -head, and get fault code
 553   3                  UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_ACK;                    // Default data packet is DATA1, and retur
             -n ACK
 554   3                  break;
 555   3              default:
 556   3                  break;
 557   3              }
 558   2              UIF_TRANSFER = 0;                                                               // Reset the trans i
             -nterrupt
 559   2          }
 560   1          if( UIF_BUS_RST )                                                                   // Device mode Bus 
             -reset
 561   1          {
 562   2              UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_NAK;
 563   2              UEP1_CTRL = bUEP_AUTO_TOG | UEP_R_RES_ACK;
 564   2              UEP2_CTRL = bUEP_AUTO_TOG | UEP_R_RES_ACK | UEP_T_RES_NAK;
 565   2              USB_DEV_AD = 0x00;
 566   2              UIF_SUSPEND = 0;
 567   2              UIF_TRANSFER = 0;
 568   2              UIF_BUS_RST = 0;                                                                // Reset Reset inter
             -rupt
 569   2          }   
 570   1          if( UIF_SUSPEND )                                                                   // USB Suspended and
             - Awake interrupt
 571   1          {   
 572   2              UIF_SUSPEND = 0;    
 573   2              if ( USB_MIS_ST & bUMS_SUSPEND )                                                // Suspended
C51 COMPILER V9.54   COMPOUND                                                              12/05/2024 11:39:01 PAGE 11  

 574   2              {   
 575   3      #ifdef DEBUG    
                          printf( "Enter LPM\r\n" );                                                  // Enter LPM flag fo
             -r debug
              #endif
 578   3                  while ( XBUS_AUX & bUART0_TX )
 579   3                  {
 580   4            
 581   4                      ;                                       // Waiting send complete ...
 582   4                  }   
 583   3                  SAFE_MOD = 0x55;    
 584   3                  SAFE_MOD = 0xAA;    
 585   3                  WAKE_CTRL = bWAK_BY_USB | bWAK_RXD0_LO;                                     // Action on USB Bus,
             - or RXD0, will awake the device
 586   3                  PCON |= PD;                                                                 // LPM
 587   3                  SAFE_MOD = 0x55;    
 588   3                  SAFE_MOD = 0xAA;    
 589   3                  WAKE_CTRL = 0x00;   
 590   3              }   
 591   2          }   
 592   1          else {                                                                              // Unexpected interr
             -upt
 593   2              USB_INT_FG = 0xFF;                                                              // Reset the interru
             -pt
 594   2          }
 595   1      }
 596          
 597          /*******************************************************************************
 598          * Function Name  : static SendKey( char *p)
 599          * Description    : ASCII to key code
 600          * Input          : char *p
 601          * Output         : None
 602          * Return         : None
 603          *******************************************************************************/
 604          
 605          static void SendKey ( char *p )
 606          {
 607   1      
 608   1        char c = *p;
 609   1          
 610   1        if( (c >= 'a') && (c <= 'z' )){
 611   2          c = c - 'a' + 'A';
 612   2        }
 613   1        
 614   1        if( (c >= 'A') && (c <= 'Z' )){
 615   2          HIDKey[2] = c - 'A' + 4;
 616   2        }
 617   1        else
 618   1          if( c >= '1' && c <= '9' )
 619   1            HIDKey[2] = c - '1' + 0X1E;
 620   1          else
 621   1          {
 622   2          switch ( c ){
 623   3            case '`' :
 624   3              HIDKey[0] = 0X08;
 625   3              HIDKey[2] = 0X15;
 626   3              break;
 627   3            case '\\':
 628   3              HIDKey[2] = 0x31;
 629   3              break;
 630   3            case ' ':
 631   3              HIDKey[2] = L_SHIFT;
C51 COMPILER V9.54   COMPOUND                                                              12/05/2024 11:39:01 PAGE 12  

 632   3              break;
 633   3            case '\r':
 634   3              HIDKey[2] = ENTER;
 635   3              break;
 636   3            case ':':
 637   3              HIDKey[0] = 0x02;
 638   3              HIDKey[2] = 0x33;
 639   3              break;
 640   3            case '+':
 641   3              HIDKey[0] = 0x000;
 642   3              HIDKey[2] = 0x57;
 643   3              break;
 644   3            case '_':
 645   3              HIDKey[0] = 0X02;
 646   3              HIDKey[2] = 0X2D;
 647   3              break;
 648   3            case '/':
 649   3              HIDKey[0] = L_CTL + L_ALT;
 650   3              HIDKey[2] = 0X16;
 651   3              break;
 652   3            case '0':
 653   3              HIDKey[2] = 0X27;
 654   3              break;
 655   3            case '.':
 656   3              HIDKey[2] = 0X37;
 657   3              break;
 658   3            case '~':
 659   3              HIDKey[0] = L_ALT;
 660   3              HIDKey[2] = 0X05;
 661   3              break;
 662   3            case '!':
 663   3              HIDKey[0] = L_ALT;
 664   3              HIDKey[2] = 0X08;
 665   3              break;
 666   3            default:
 667   3              break;
 668   3          }
 669   2        }
 670   1        
 671   1        mDelaymS( 20 );                                       //emulate the press down and pop up
 672   1        while(FLAG == 0);                                                           // Upload the key
 673   1        Enp1IntIn();            
 674   1        while(FLAG == 0);                                             
 675   1        mDelaymS( 20 );
 676   1        HIDKey[0] = 0X00;                 
 677   1        HIDKey[2] = 0X00;                                                             // Reset the key
 678   1        while(FLAG == 0);                                                       
 679   1        Enp1IntIn();      
 680   1        while(FLAG == 0); 
 681   1      }
 682          
 683          /*******************************************************************************
 684          * Function Name  : static void UploadData(void)
 685          * Description    : Upload the HID code
 686          * Input          : None
 687          * Output         : None
 688          * Return         : None
 689          *******************************************************************************/
 690          static void UploadData(void)
 691          {
 692   1        UINT8 i;
 693   1        for( i = 1; i < 64 ;i ++ )
C51 COMPILER V9.54   COMPOUND                                                              12/05/2024 11:39:01 PAGE 13  

 694   1          HIDCom[i] += rand();
 695   1      }
 696          /*******************************************************************************
 697          * Function Name  : extern HIDValueHandle( void )
 698          * Description    : Upload the HID code
 699          * Input          : None
 700          * Output         : None
 701          * Return         : None
 702          *******************************************************************************/
 703          extern void HIDValueHandle( void )
 704          {
 705   1        static UINT8 rotateFlag = 0;                                // When upload keys complete, upload EP2 data
 706   1        UINT16 KeyData = TouchKeyButton;
 707   1        if(TKEY_CTRL&bTKC_IF)                                       //query key
 708   1        {
 709   2           KeyData = TKEY_DAT;                                      //
 710   2      #ifdef DE_PRINTF
 711   2           printf("B.=  %04x\n",KeyData&0x7FFF);    
 712   2      #endif
 713   2        }   
 714   1        if (rotateFlag &&(KeyData < (TouchKeyButton-100)))          //100 灵敏度调节          
 715   1        {
 716   2          HIDCom[0] += 0x01;  
 717   2          UploadData();
 718   2      
 719   2          Enp2IntIn();  
 720   2        }     
 721   1        else if(rotateFlag == 0)
 722   1        {       
 723   2              SendKey(pStr);                                         // Upload path
 724   2          pStr++; 
 725   2          if(*pStr == '\0')     
 726   2          {
 727   3            SendKey( "~" );                                      // Upload ALT+B
 728   3            mDelaymS( 200 );  
 729   3            rotateFlag = 1;
 730   3          }   
 731   2        } 
 732   1      
 733   1      }
 734          
 735          /**************************** END *************************************/
 736          
 737          void usb_send_key (char *p)
 738          {
 739   1      
 740   1        char c = *p;
 741   1        
 742   1        memset(HIDKey, 0, sizeof(HIDKey)); 
 743   1          
 744   1        if( (c >= 'a') && (c <= 'z' )){
 745   2          c = c - 'a' + 'A';
 746   2        }
 747   1        
 748   1        if( (c >= 'A') && (c <= 'Z' )){
 749   2          HIDKey[2] = c - 'A' + 4;
 750   2        }
 751   1        else
 752   1          if( c >= '1' && c <= '9' )
 753   1            HIDKey[2] = c - '1' + 0X1E;
 754   1          else
 755   1          {
C51 COMPILER V9.54   COMPOUND                                                              12/05/2024 11:39:01 PAGE 14  

 756   2          switch ( c ){
 757   3            case '#':     /* f7 key */
 758   3              HIDKey[0] = 0x00;
 759   3              HIDKey[2] = 0x40;
 760   3              break;
 761   3      
 762   3            case '`' :
 763   3              HIDKey[0] = 0X08;
 764   3              HIDKey[2] = 0X15;
 765   3              break;
 766   3            case '\\':
 767   3              HIDKey[2] = 0x31;
 768   3              break;
 769   3            case ' ':
 770   3              HIDKey[2] = L_SHIFT;
 771   3              break;
 772   3            case '\r':
 773   3              HIDKey[2] = ENTER;
 774   3              break;
 775   3            case ':':
 776   3              HIDKey[0] = 0x02;
 777   3              HIDKey[2] = 0x33;
 778   3              break;
 779   3            case '+':
 780   3              HIDKey[0] = 0x000;
 781   3              HIDKey[2] = 0x57;
 782   3              break;
 783   3            case '_':
 784   3              HIDKey[0] = 0X02;
 785   3              HIDKey[2] = 0X2D;
 786   3              break;
 787   3            case '/':
 788   3              HIDKey[0] = L_CTL + L_ALT;
 789   3              HIDKey[2] = 0X16;
 790   3              break;
 791   3            case '0':
 792   3              HIDKey[2] = 0X27;
 793   3              break;
 794   3            case '.':
 795   3              HIDKey[2] = 0X37;
 796   3              break;
 797   3            case '~':
 798   3              HIDKey[0] = L_ALT;
 799   3              HIDKey[2] = 0X05;
 800   3              break;
 801   3            case '!':
 802   3              HIDKey[0] = L_ALT;
 803   3              HIDKey[2] = 0X08;
 804   3              break;
 805   3            default:
 806   3              break;
 807   3          }
 808   2        }
 809   1        
 810   1        mDelaymS( 20 );                                       //emulate the press down and pop up
 811   1        while(FLAG == 0);                                                           // Upload the key
 812   1        Enp1IntIn();            
 813   1        while(FLAG == 0);                                             
 814   1        mDelaymS( 20 );
 815   1        HIDKey[0] = 0X00;                 
 816   1        HIDKey[2] = 0X00;                                                             // Reset the key
 817   1        while(FLAG == 0);                                                       
C51 COMPILER V9.54   COMPOUND                                                              12/05/2024 11:39:01 PAGE 15  

 818   1        Enp1IntIn();      
 819   1        while(FLAG == 0); 
 820   1      }
 821          
 822          /**
 823           * @brief 计算从compound_data[1]开始的len - 1个字节的校验和
 824           * 
 825           * @param compound_data 
 826           * @param len 这里的len指的是从compound_data[2]中提取的长度值
 827           * @return UINT8 
 828           */
 829          UINT8 usb_calculate_checksum(UINT8 *compound_data, UINT8 len)
 830          {
 831   1        UINT8 checksum = 0;
 832   1        UINT8 i;
 833   1      
 834   1        for (i = 1; i < len; i++)
 835   1        {
 836   2          checksum += compound_data[i];
 837   2        }
 838   1      
 839   1        return checksum;
 840   1      }
 841          
 842          UINT8 usb_check_valid_packet(UINT8 *compound_data, UINT8 len)
 843          {
 844   1        /* 注意：接收到的数据compound_data[0]是固定的，0x00，这一位不考虑；实际判断从compound_data[1]开始考虑 */
 845   1      
 846   1        /* 协议格式是 帧头（1 byte）+ 长度（1 byte）(计算的是从帧头到校验和的长度（包括）) + OPCODE (1 byte) + DA
             -TA（不固定） + Checksum (1 byte) */
 847   1        /* 例如：0xAA 0x04 0x01 0x0A  */
 848   1        /* 帧头是0xAA，长度是0x04，OPCODE是0x01，没有DATA，checksum是0XAA + 0x04 + 0x01 = 0xB0 */
 849   1        /* 判断缓冲区接收到的数据是否是一个合法的数据包 */
 850   1      
 851   1        /* 判断流程：1. 判断compound_data[1]是否是一个合法的帧头0xAA */
 852   1        /*      2. 如果是一个合法的帧头，紧接着从compound_data[2]提取这个字节的长度 */
 853   1        /*      3. 根据协议格式计算得到checksum是位于compound_data[x]的x是多少 */
 854   1        /*      4. 再计算这包数据的checksum，与协议里面的checksum大小是否一致：如果一直，那就进入判断OPCODE的环节 *
             -/
 855   1      
 856   1        UINT8 expected_checksum = 0;
 857   1        UINT8 recved_checksum = 0;
 858   1        UINT8 length = 0;
 859   1      
 860   1        if (compound_data[1] != 0xAA)
 861   1        {
 862   2          return 0;
 863   2        }
 864   1      
 865   1        length = compound_data[2];
 866   1      
 867   1        expected_checksum = usb_calculate_checksum(compound_data, length);
 868   1        recved_checksum = compound_data[length];
 869   1        if (expected_checksum != recved_checksum)
 870   1        {
 871   2          return 0;
 872   2        }
 873   1      
 874   1        return 1;
 875   1      
 876   1      }
*** WARNING C280 IN LINE 842 OF Compound.C: 'len': unreferenced local variable
C51 COMPILER V9.54   COMPOUND                                                              12/05/2024 11:39:01 PAGE 16  

 877          
 878          
 879          // UINT8 usb_check_heartbeat_packet(UINT8 *compound_data, UINT8 len)
 880          // {
 881          
 882          //  UINT8 i = 0;
 883          //  if (compound_data[0] == 0x00 && compound_data[1] == 0x01)
 884          //  {
 885          //    ;
 886          //  }
 887          
 888            // UINT8 i;
 889              // // Iterate through the data buffer
 890              // for (i = 0; i < len; i++)
 891              // {
 892              //     if (compound_data[i] == 0xAA)  // Check if any byte equals 0xAA
 893              //     {
 894              //         return 1;  // Found 0xAA, return 1
 895              //     }
 896              // }
 897              // return 0;  // If no 0xAA is found, return 0
 898          //    UINT8 checksum = 0;
 899          //    UINT8 i;
 900          //    
 901          //    if (len != 10)
 902          //    {
 903          //        return 0;
 904          //    }
 905          //    if (compound_data[0] != PACKET_HEADER)
 906          //    {
 907          //        return 0;
 908          //    }
 909          //    if (compound_data[1] != PACKET_OPCODE_HEART)
 910          //    {
 911          //        return 0;
 912          //    }
 913          //    for (i = 0; i < len - 1; i++)
 914          //    {
 915          //        checksum += compound_data[i];
 916          //    }
 917          //    if (checksum != compound_data[len - 1])
 918          //    {
 919          //        return 0;
 920          //    }
 921          //    return 1;
 922          // }
 923          
 924          /**
 925           * @brief 
 926           * 
 927           * @param len 
 928           */
 929          void compound_process_recv_data(UINT8 len)
 930          {
 931   1        /* 响应数据包格式 */
 932   1        /* compound_response_data[0] =  0x01            1byte                       */
 933   1        /* compound_response_data[1] =  PACKET_HEADER         1byte                         */
 934   1        /* compound_response_data[2] =  LENGTH            1byte                       */
 935   1        /* compound_response_data[3] =  OPCODE            1byte                       */
 936   1        /* compound_response_data[4] =  ERROCDE           1byte                       */
 937   1        /* compound_response_data[5 ~ x] =  DATA            不固定，根据OPCODE不同，DATA内容不同            */
 938   1        /* compound_response_data[x + 1] =  CHECKSUM        1byte                       */
C51 COMPILER V9.54   COMPOUND                                                              12/05/2024 11:39:01 PAGE 17  

 939   1      
 940   1        if (usb_check_valid_packet(compound_received_data, len))  // 合法数据包
 941   1        {
 942   2          // 数据包合法，继续处理
 943   2          UINT8 opcode = compound_received_data[3];
 944   2      
 945   2          switch (opcode)
 946   2          {
 947   3            case USB_OP_HEARTBEAT:
 948   3            {
 949   4              // 心跳包:心跳包的组装的data是
 950   4              //VERSION_STR[0];
 951   4                //VERSION_STR[2];
 952   4                //VERSION_STR[4];
 953   4                //DEVICE_VID_L;           
 954   4                //DEVICE_VID_H;           
 955   4                //DEVICE_PID_L;           
 956   4                //DEVICE_PID_H;
 957   4              // ERRCODE = 0x00
 958   4      
 959   4              // 1. 业务逻辑，处理心跳包功能
 960   4      
 961   4              UINT8 checksum = 0;
 962   4              UINT8 length =  12;
 963   4              UINT8 i = 0;
 964   4      
 965   4      //        g_compound_heartbeat_timer = 0;
 966   4              g_compound_heartbeat_flag = 1;
 967   4      //        if (!first_hb_flag)
 968   4      //        {
 969   4      //          first_hb_flag = 1;
 970   4      //          timer0_register_cb(led_flash_handler);
 971   4      //        }
 972   4      
 973   4              // 2. 组装响应包并发送
 974   4              compound_response_data[0] = 0x01;   // 协议固定的，第一个字节得是0x01
 975   4              compound_response_data[1] = PACKET_HEADER;
 976   4              compound_response_data[2] = length;
 977   4              compound_response_data[3] = opcode;
 978   4              compound_response_data[4] = 0x00; // ERRCODE = 0x00
 979   4      
 980   4              compound_response_data[5] = VERSION_STR[0];
 981   4              compound_response_data[6] = VERSION_STR[2];
 982   4              compound_response_data[7] = VERSION_STR[4];
 983   4              compound_response_data[8] = DEVICE_VID_L;
 984   4              compound_response_data[9] = DEVICE_VID_H;
 985   4              compound_response_data[10] = DEVICE_PID_L;
 986   4              compound_response_data[11] = DEVICE_PID_H;
 987   4      
 988   4              // 计算校验和，计算[1] ~ [11]的校验和
 989   4              for (i = 1; i < 12; i++)
 990   4              {
 991   5                checksum += compound_response_data[i];
 992   5              }
 993   4              compound_response_data[12] = checksum;
 994   4      
 995   4              // 填充剩余的字节为0x00，直到64字节
 996   4              memset(&compound_response_data[13], 0, 51);  // 64 - 13 = 51
 997   4      
 998   4              // 发送数据
 999   4              memcpy(&Ep2Buffer[BUFFER_SIZE], compound_response_data, 64);  
1000   4                  UEP2_T_LEN = 64;
C51 COMPILER V9.54   COMPOUND                                                              12/05/2024 11:39:01 PAGE 18  

1001   4                  UEP2_CTRL = (UEP2_CTRL & ~MASK_UEP_T_RES) | UEP_T_RES_ACK;
1002   4      
1003   4              break;
1004   4            }
1005   3            case USB_OP_WL_LEARNMATCH:
1006   3            {
1007   4              // 学习匹配
1008   4              // 学习匹配没有data
1009   4              // ERRCODE = 0x00
1010   4      
1011   4              // 1. 业务逻辑，学习匹配无线按键控制USB键盘
1012   4              // 拉低P1^6 4s，进入学习模式，然后拉高
1013   4              // 首先考虑阻塞可不可以。如果阻塞4s，那么久不能处理其他的数据包，这会直接导致心跳包的处理失败，进而重
             -USB设备，这是不允许的
1014   4              // 所以，必须使用非阻塞方法。想法是利用原有的定时器，原来的定时器是定时10ms，那就是可以在这个主程序里
             -孀⒉峄氐骱数，然后在回调函数里面定时4s，然后就是主程序里4s后主程序里来一个全局变量置位，
1015   4              // 上位机下发学习命令，状态机接收到，立刻回复usb主机开始处理学习，然后进入学习状态：拉低P1.6 4s，然后
             -高；这个怎么通过非阻塞的方法实现呢？
1016   4      
1017   4              UINT8 checksum = 0;
1018   4              UINT8 length = 5; // header + length + opcode + ERRCODE + checksum
1019   4              UINT8 i = 0;
1020   4      
1021   4      
1022   4              if (learnmatch_state == LEARNMATCH_STATE_IDLE)
1023   4              {
1024   5                WL_LEARN_PIN = 0;
1025   5                learnmatch_state = LEARNMATCH_STATE_ACTIVE;
1026   5                g_learnmatch_timer = 0;
1027   5              }
1028   4      
1029   4              // 2. 组装响应包并发送
1030   4              compound_response_data[0] = 0x01;   // 协议固定的，第一个字节得是0x01
1031   4              compound_response_data[1] = PACKET_HEADER;
1032   4              compound_response_data[2] = length;
1033   4              compound_response_data[3] = opcode;
1034   4              compound_response_data[4] = 0x00; // ERRCODE = 0x00,表示成功
1035   4      
1036   4              for (i = 1; i < 5; i++)
1037   4              {
1038   5                checksum += compound_response_data[i];
1039   5              }
1040   4              compound_response_data[5] = checksum;
1041   4              memset(&compound_response_data[6], 0, 58);  // 64 - 6 = 58
1042   4      
1043   4              // 发送数据
1044   4              memcpy(&Ep2Buffer[BUFFER_SIZE], compound_response_data, 64);  
1045   4              UEP2_T_LEN = 64;
1046   4              UEP2_CTRL = (UEP2_CTRL & ~MASK_UEP_T_RES) | UEP_T_RES_ACK;
1047   4      
1048   4              break;
1049   4            }
1050   3            case USB_OP_WL_CLEANMATCH:
1051   3            {
1052   4              // 清空匹配
1053   4              // 清空匹配没有data
1054   4              // ERRCODE = 0x00
1055   4              // 清空匹配和学习匹配的区别是，清空匹配是拉低11s，然后拉高
1056   4              UINT8 checksum = 0;
1057   4              UINT8 length = 5; // header + length + opcode + ERRCODE + checksum
1058   4              UINT8 i = 0;
1059   4      
C51 COMPILER V9.54   COMPOUND                                                              12/05/2024 11:39:01 PAGE 19  

1060   4      
1061   4              if (cleanmatch_state == CLEANMATCH_STATE_IDLE)
1062   4              {
1063   5                WL_LEARN_PIN = 0;
1064   5                cleanmatch_state = CLEANMATCH_STATE_ACTIVE;
1065   5                g_cleanmatch_timer = 0;
1066   5              }
1067   4      
1068   4              // 2. 组装响应包并发送
1069   4              compound_response_data[0] = 0x01;   // 协议固定的，第一个字节得是0x01
1070   4              compound_response_data[1] = PACKET_HEADER;
1071   4              compound_response_data[2] = length;
1072   4              compound_response_data[3] = opcode;
1073   4              compound_response_data[4] = 0x00; // ERRCODE = 0x00,表示成功
1074   4      
1075   4              for (i = 1; i < 5; i++)
1076   4              {
1077   5                checksum += compound_response_data[i];
1078   5              }
1079   4              compound_response_data[5] = checksum;
1080   4              memset(&compound_response_data[6], 0, 58);  // 64 - 6 = 58
1081   4      
1082   4              // 发送数据
1083   4              memcpy(&Ep2Buffer[BUFFER_SIZE], compound_response_data, 64);  
1084   4              UEP2_T_LEN = 64;
1085   4              UEP2_CTRL = (UEP2_CTRL & ~MASK_UEP_T_RES) | UEP_T_RES_ACK;
1086   4      
1087   4              break;
1088   4            }
1089   3      
1090   3            default:
1091   3            {
1092   4              // 未知的OPCODE, 需要回复错误码
1093   4              // 未知的OPCODE的data是空的
1094   4              // ERRCODE = 0x01
1095   4              break;
1096   4            }
1097   3      
1098   3          }
1099   2      
1100   2        }
1101   1        else  // 非法数据包 echo模式
1102   1        {
1103   2              memcpy(compound_response_data, compound_received_data, len);
1104   2              memcpy(&Ep2Buffer[BUFFER_SIZE], compound_response_data, len);
1105   2              UEP2_T_LEN = len;
1106   2              UEP2_CTRL = (UEP2_CTRL & ~MASK_UEP_T_RES) | UEP_T_RES_ACK;
1107   2        }
1108   1      
1109   1          // UINT8 checksum = 0;
1110   1          // UINT8 i;  /* 移到函数开始处声明 */
1111   1          
1112   1      
1113   1        
1114   1          // if (usb_check_heartbeat_packet(compound_received_data, len))
1115   1          // {
1116   1        //  g_compound_heartbeat_timer = 0;
1117   1        //  g_compound_heartbeat_flag = 1;
1118   1      
1119   1          //     // compound_response_data[0] = PACKET_HEADER;
1120   1          //     // compound_response_data[1] = PACKET_OPCODE_HEART;
1121   1          //     // compound_response_data[2] = VERSION_STR[0];
C51 COMPILER V9.54   COMPOUND                                                              12/05/2024 11:39:01 PAGE 20  

1122   1          //     // compound_response_data[3] = VERSION_STR[2];
1123   1          //     // compound_response_data[4] = VERSION_STR[4];
1124   1          //     // compound_response_data[5] = DEVICE_VID_L;           
1125   1          //     // compound_response_data[6] = DEVICE_VID_H;           
1126   1          //     // compound_response_data[7] = DEVICE_PID_L;           
1127   1          //     // compound_response_data[8] = DEVICE_PID_H;           
1128   1              
1129   1          //     // for(i = 0; i < 9; i++) 
1130   1          //     // {
1131   1          //     //     checksum += compound_response_data[i];
1132   1          //     // }
1133   1          //     // compound_response_data[9] = checksum;
1134   1              
1135   1          //     // memcpy(&Ep2Buffer[BUFFER_SIZE], compound_response_data, 10);  
1136   1          //     // UEP2_T_LEN = 10;
1137   1          //     // UEP2_CTRL = (UEP2_CTRL & ~MASK_UEP_T_RES) | UEP_T_RES_ACK;
1138   1              
1139   1          //     // if (!first_hb_flag)
1140   1          //     // {
1141   1          //     //     first_hb_flag = 1;
1142   1          //     //     timer0_register_cb(led_flash_handler);
1143   1          //     // }
1144   1        //  compound_response_data[0] = 0x01;
1145   1        //  compound_response_data[1] = PACKET_HEADER;
1146   1          //     compound_response_data[2] = PACKET_OPCODE_HEART;
1147   1          //     compound_response_data[3] = VERSION_STR[0];
1148   1          //     compound_response_data[4] = VERSION_STR[2];
1149   1          //     compound_response_data[5] = VERSION_STR[4];
1150   1          //     compound_response_data[6] = DEVICE_VID_L;           
1151   1          //     compound_response_data[7] = DEVICE_VID_H;           
1152   1          //     compound_response_data[8] = DEVICE_PID_L;           
1153   1          //     compound_response_data[9] = DEVICE_PID_H;           
1154   1              
1155   1          //     for(i = 1; i < 10; i++) 
1156   1          //     {
1157   1          //         checksum += compound_response_data[i];
1158   1          //     }
1159   1          //     compound_response_data[10] = checksum;
1160   1          //     // 填充剩余的字节为0x00，直到64字节
1161   1          //     memset(&compound_response_data[11], 0, 53);  // 64 - 11 = 53 
1162   1      
1163   1          //     memcpy(&Ep2Buffer[BUFFER_SIZE], compound_response_data, 64);  
1164   1          //     UEP2_T_LEN = 64;
1165   1          //     UEP2_CTRL = (UEP2_CTRL & ~MASK_UEP_T_RES) | UEP_T_RES_ACK;
1166   1              
1167   1          //     if (!first_hb_flag)
1168   1          //     {
1169   1          //         first_hb_flag = 1;
1170   1          //         timer0_register_cb(led_flash_handler);
1171   1          //     }
1172   1          // }
1173   1          // else
1174   1          // {
1175   1          //     memcpy(compound_response_data, compound_received_data, len);
1176   1          //     memcpy(&Ep2Buffer[BUFFER_SIZE], compound_response_data, len);
1177   1          //     UEP2_T_LEN = len;
1178   1          //     UEP2_CTRL = (UEP2_CTRL & ~MASK_UEP_T_RES) | UEP_T_RES_ACK;
1179   1          // }
1180   1      }
1181          
1182          

C51 COMPILER V9.54   COMPOUND                                                              12/05/2024 11:39:01 PAGE 21  


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2840    ----
   CONSTANT SIZE    =    228    ----
   XDATA SIZE       =    231      19
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
