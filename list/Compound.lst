C51 COMPILER V9.54   COMPOUND                                                              12/02/2024 10:23:19 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE COMPOUND
OBJECT MODULE PLACED IN .\obj\Compound.obj
COMPILER INVOKED BY: D:\installations\keil_c51\C51\BIN\C51.EXE Compound.C LARGE OPTIMIZE(6,SPEED) BROWSE INCDIR(.\hal_dr
                    -iver) DEBUG OBJECTEXTEND PRINT(.\list\Compound.lst) TABS(2) OBJECT(.\obj\Compound.obj)

line level    source

   1          /********************************** (C) COPYRIGHT ******************************
   2          * File Name          :Compound_Dev.C                        
   3          * Author             : WCH                                                      
   4          * Version            : V1.2                                                     
   5          * Date               : 2017/02/24                                               
   6          * Description        : A demo for USB compound device created by CH554, support 
   7                       keyboard , and HID-compliant device.                     
   8          ********************************************************************************/
   9          
  10          #include  ".\Public\CH554.H"
  11          #include  ".\Public\DEBUG.H"
  12          #include  "compound.h"
  13          #include  "key.h"
  14          
  15          #include  <stdio.h>
  16          #include  <stdlib.h>
  17          #include  <string.h>
  18          
  19          
  20          #define   THIS_ENDP0_SIZE         DEFAULT_ENDP0_SIZE
  21          #define   BUFFER_SIZE       64
  22          #define   DUAL_BUFFER_SIZE    128
  23          #define   UsbSetupBuf         ((PUSB_SETUP_REQ)Ep0Buffer)
  24          #define   L_WIN           0X08
  25          #define   L_ALT           0X04
  26          #define   L_SHIFT         0X02
  27          #define   L_CTL         0X01
  28          #define   R_WIN           0X80
  29          #define   R_ALT           0X40
  30          #define   R_SHIFT         0X20
  31          #define   R_CTL         0X10
  32          #define   SPACE         0X2C
  33          #define   ENTER         0X28
  34          
  35          #define MOUSE 0
  36          
  37          #pragma  NOAREGS
  38          
  39          UINT8X    Ep0Buffer[THIS_ENDP0_SIZE]  _at_ 0x0000;                  // Endpoint 0, buffer OUT/OUT，the address must
             - be even.
  40          UINT8X    Ep1Buffer[BUFFER_SIZE]    _at_ 0x000A;                  // Endpoint 1, buffer IN，the address must be even
             -.
  41          UINT8X    Ep2Buffer[DUAL_BUFFER_SIZE] _at_ 0x0050;                  // Endpoint 2, buffer OUT[64]+IN[64]，the addre
             -ss must be even.
  42          
  43          
  44          /**************************** Global variable ********************************/ 
  45          UINT8   volatile  SetupReq, SetupLen, UsbConfig;
  46          UINT8 volatile  EnumOK, FLAG;
  47          PUINT8    pDescr;                                                                 // USB enumerate complete
             - flag.
  48          USB_SETUP_REQ             SetupReqBuf;                                    // A buffer for Setup package.
  49          
  50          char code sPath[] = "`  C:\\HID_RECV.EXE   \r   ";                    // The path for the software. SPACE for delay
C51 COMPILER V9.54   COMPOUND                                                              12/02/2024 10:23:19 PAGE 2   

  51          char *pStr = sPath;
  52          
  53          UINT8 HIDCom[64] = {0};                       
  54          UINT8 HIDKey[8] = {0};
  55          
  56          static UINT8 compound_received_data[BUFFER_SIZE] = {0};                   // 存储从PC中接收的数据
  57          static UINT8 compound_response_data[BUFFER_SIZE] = {0};
  58          volatile UINT8 g_data_ready;
  59          volatile UINT8 g_data_len;
  60          #define PACKET_HEADER         0xAA
  61          #define USB_OP_HEARTBEAT      0x10
  62          #define USB_OP_WL_LEARNMATCH    0x1F
  63          #define USB_OP_WL_CLEANMATCH    0X20
  64          
  65          
  66          #define VERSION_STR         "1.0.0"
  67          #define DEVICE_VID_L     0x31    // VID低字节
  68          #define DEVICE_VID_H     0x51    // VID高字节
  69          #define DEVICE_PID_L     0x07    // PID低字节
  70          #define DEVICE_PID_H     0x20    // PID高字节
  71          static UINT8 first_hb_flag = 0;
  72          extern void soft_reset(void);
  73          extern void timer0_register_cb(void (*cb)(void));  // 声明timer注册函数
  74          extern void led_flash_handler(void);               // 声明回调函数
  75          // 1. 先声明函数原型
  76          void compound_process_recv_data(UINT8 len);
  77          UINT8 usb_check_heartbeat_packet(UINT8 *compound_data, UINT8 len);
  78          volatile UINT8 g_compound_heartbeat_flag = 0;
  79          volatile UINT8 g_compound_heartbeat_timer = 0;
  80          
  81          // 定义学习状态
  82          
  83          volatile learnmatch_state_t learnmatch_state = LEARNMATCH_STATE_IDLE;
  84          volatile UINT16 g_learnmatch_timer = 0; // 计时器，单位为10ms
  85          volatile cleanmatch_state_t cleanmatch_state = CLEANMATCH_STATE_IDLE;
  86          volatile UINT16 g_cleanmatch_timer = 0; // 计时器，单位为10ms
  87          
  88          
  89          
  90          
  91          /**************************** Device Descriptor *************************************/
  92          UINT8C DevDesc[18] = {                                // Device Descriptor
  93            0x12,0x01,
  94            0x10,0x01,
  95            0x00,0x00,
  96            0x00,0x08,                      
  97            0x31,0x51,                                    // Vendor ID   |  VID =  0X5131///413c
  98            0x07,0x20,                                    // Product ID  |  PID = 0X2007 /// 2105
  99          //  0x00,0x01,
 100          //  0x05,0x21,
 101            0x00,0x11,                                    // bcdDevice    
 102            0x00,0x00,
 103            0x00,0x01
 104          };
 105          /**************************** HID Report Descriptor *********************************/
 106          UINT8C KeyRepDesc[65] =                               // Report Descriptor, DELL Keyboard
 107          {
 108            0x05, 0x01,     // Usage page Generatic Desktop
 109            0x09, 0x06,     // Usage keyboard
 110            0xa1, 0x01,     // Collation Application
 111            0x05, 0x07,     // Usafe page (key code)
 112            0x19, 0xe0,     // Usage Min ( E0 -->  L_CTL)
C51 COMPILER V9.54   COMPOUND                                                              12/02/2024 10:23:19 PAGE 3   

 113            0x29, 0xe7,     // Usage MAX ( E7 --> R_GUI )
 114            0x15, 0x00,     // Logical min
 115            0x25, 0x01,     // Logical max
 116            0x95, 0x08,     // Report count ( 8 )
 117            0x75, 0x01,     // Report size  ( 1 )
 118            0x81, 0x02,     // Input ( Data, Variable, Absolute )
 119            0x95, 0x08,     // Report count ( 8 )
 120            0x75, 0x01,     // Report size  ( 1 )
 121            0x81, 0x01,     // Input ( const )
 122            0x05, 0x08,     // Usage page( LED )
 123            0x19, 0x01,     // Usage min ( 1 )
 124            0x29, 0x03,     // Usage max ( 3 )
 125            0x95, 0x03,     // Report count ( 3 )
 126            0x75, 0x01,     // Report size ( 1 )
 127            0x91, 0x02,     // Output ( Data, Variable, Absolute )
 128            0x95, 0x01,     // Report count ( 1 )
 129            0x75, 0x05,     // Report size ( 5 )
 130            0x91, 0x01,     // Output ( const )
 131            0x05, 0x07,     // Usage page ( key code )
 132            0x19, 0x00,     // Usage min ( 0H )
 133            0x2a, 0xff, 0x00, // Usage max ( FFH )
 134            0x15, 0x00,     // Logical min ( 0H )
 135            0x26, 0xff, 0x00, // Logical max ( FFH )
 136            0x95, 0x06,     // Report count ( 6 )
 137            0x75, 0x08,     // Report size ( 8 )
 138            0x81, 0x00,     // Input ( Data, Array, Absolute )
 139            0xc0        // End collection
 140          };
 141          
 142          UINT8C ComRepDesc[34] =                               // Report Descriptor, Composite device
 143          {
 144            0x06, 0x00, 0xff,   // Usage page Vendor defined
 145            0x09, 0x01,     // Usage keyboard
 146            0xa1, 0x01,     // Collation Application
 147            0x09, 0x02,     // Mouse
 148            0x15, 0x00,     // Logical min ( 0H )
 149            0x26, 0x00, 0xff, // Logical max ( FFH )
 150            0x75, 0x08,     // Report size ( 08H )
 151            0x95, 0x40,     // Report count ( 40H )
 152            0x81, 0x06,     // Input ( Data, Relative, Wrap )
 153            0x09, 0x02,     // Mouse
 154            0x15, 0x00,     // Logical min ( 0H )
 155            0x26, 0x00, 0xff, // Logical max ( FFH )
 156            0x75, 0x08,     // Report size ( 08H )
 157            0x95, 0x40,     // Report count ( 40H )
 158            0x91, 0x06,     // Output ( Data, Relative, Wrap )
 159            0xc0,
 160          };
 161          
 162          
 163          UINT8C CfgDesc[9+9+9+7+9+9+7+7] =
 164          {
 165              0x09,0x02,0x42,0x00,0x02,0x01,0x00,0xA0,0x32,                         // Configure Descriptor
 166                 
 167          //  0x09,0x02,0x22,0x00,0x01,0x01,0x00,0xA0,0x32,
 168            0x09,0x04,0x00,0x00,0x01,0x03,0x01,0x01,0x00,                         // Interface Descriptor, keyboard
 169              0x09,0x21,0x11,0x01,0x00,0x01,0x22,sizeof(KeyRepDesc),0x00,                 // HID Descriptor
 170              0x07,0x05,0x81,0x03,0x08,0x00,0x0a,                                   // Endpoint Descriptor, 50ms
 171          
 172          //   0x09,0x02,0x29,0x00,0x01,0x01,0x00,0xA0,0x32,                        // Configure Descriptor 
 173          //    0x09,0x04,0x00,0x00,0x02,0x03,0x00,0x00,0x00,                         // Interface Descriptor, Composite d
             -evice， 2 EPs
C51 COMPILER V9.54   COMPOUND                                                              12/02/2024 10:23:19 PAGE 4   

 174            0x09,0x04,0x01,0x00,0x02,0x03,0x00,0x00,0x00,                         // Interface Descriptor, Composite device
             -， 2 EPs
 175              0x09,0x21,0x10,0x01,0x21,0x01,0X22,sizeof(ComRepDesc),0x00,                 // HID Descriptor
 176              0x07,0x05,0x82,0x03,0x40,0x00,0x32,                                   // Endpoint Descriptor, 10ms, IN
 177            0x07,0x05,0x02,0x03,0x40,0x00,0x0a                        // Endpoint Descriptor, 10ms, OUT
 178          };
 179          
 180          void compound_process_recv_data(UINT8 len);
 181          
 182          /*******************************************************************************
 183          * Function Name  : USBDeviceInit()
 184          * Description    : Configure USB mode ，USB device init configure.Configure tie Endpoint, compound device,
             - 
 185                             Endpoint 0 control trans, Endpoint 1/2 interrupt(IN).
 186          * Input          : None
 187          * Output         : None
 188          * Return         : None
 189          *******************************************************************************/
 190          void USBDeviceInit()
 191          {
 192   1          IE_USB = 0;
 193   1          USB_CTRL = 0x00;                                                           // Device mode
 194   1        
 195   1          UEP1_DMA = Ep1Buffer;                                                      // Endpoint 1 uploard addre
             -ss
 196   1          UEP0_DMA = Ep0Buffer;                                                      // Endpoint 0 trans address
 197   1          UEP2_DMA = Ep2Buffer;                                                      // Endpoint 2 uploard addre
             -ss  
 198   1          UEP4_1_MOD = UEP4_1_MOD | bUEP1_TX_EN & ~(bUEP1_RX_EN | bUEP1_BUF_MOD | bUEP4_RX_EN | bUEP4_TX_EN); //
             - Endpoint 1 sigle 64 byte send buffer, Endpoint 4 disable
 199   1          UEP1_CTRL = bUEP_AUTO_TOG | UEP_T_RES_NAK;                                 // Endpoint 1 auto Toggle f
             -lag, In translation return NAK
 200   1          UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_NAK;                                 // Endpoint 0 OUT trans ret
             -urn ACK, IN trans return NAK    
 201   1      
 202   1          UEP2_3_MOD = UEP2_3_MOD | bUEP2_TX_EN | bUEP2_RX_EN & ~bUEP2_BUF_MOD;      // Endpoint 2 sigle 64 byte
             - send buffer OUT[64]+IN[64] (OUT first)
 203   1          UEP2_CTRL = bUEP_AUTO_TOG | UEP_T_RES_NAK;                                 // Endpoint 2 auto Toggle f
             -lag, IN trans return NAK
 204   1          
 205   1          USB_DEV_AD = 0x00;                                                         // Initial the device addres
             -s
 206   1          UDEV_CTRL = bUD_PD_DIS;                                                    // Disable DM/PM PULL_DOWN.
 207   1          USB_CTRL = bUC_DEV_PU_EN | bUC_INT_BUSY | bUC_DMA_EN;                      // Enable inter PULL_UP. Aut
             -o return NAK, during interrupt routing, if the interrupt flag.
 208   1          UDEV_CTRL |= bUD_PORT_EN;                                                  // Enable USB port.
 209   1          USB_INT_FG = 0xFF;                                                         // Clear interrupt flag.
 210   1          USB_INT_EN = bUIE_SUSPEND | bUIE_TRANSFER | bUIE_BUS_RST;                  // Enable USB interrupt
 211   1          IE_USB = 1;                                                                // Enable USB interrupt
 212   1      }
 213          
 214          /*******************************************************************************
 215          * Function Name  : Enp1IntIn()
 216          * Description    : USB Device mode Endpoint 1 upload data, Interrupt mode
 217          * Input          : None
 218          * Output         : None
 219          * Return         : None
 220          *******************************************************************************/
 221          static void Enp1IntIn( void )
 222          {     
 223   1          memcpy( Ep1Buffer, HIDKey, sizeof(HIDKey));                                   // Upload data
 224   1          UEP1_T_LEN = sizeof(HIDKey);                                                  // Upload length
C51 COMPILER V9.54   COMPOUND                                                              12/02/2024 10:23:19 PAGE 5   

 225   1          UEP1_CTRL = UEP1_CTRL & ~ MASK_UEP_T_RES | UEP_T_RES_ACK;                     // Return ACK
 226   1          while(( UEP1_CTRL & MASK_UEP_T_RES ) == UEP_T_RES_ACK);                       // Waiting upload complete
             -, avoid overwriting 
 227   1      }
 228          /*******************************************************************************
 229          * Function Name  : Enp2IntIn()
 230          * Description    : USB Device mode Endpoint 2 upload data, Interrupt mode 
 231          * Input          : None
 232          * Output         : None
 233          * Return         : None
 234          *******************************************************************************/
 235          static void Enp2IntIn( void )
 236          { 
 237   1          memcpy( &Ep2Buffer[64], HIDCom, sizeof(HIDCom) );                               // Upload data
 238   1          UEP2_T_LEN = sizeof(HIDCom);                                                  // Upload length
 239   1          UEP2_CTRL = UEP2_CTRL & ~ MASK_UEP_T_RES | UEP_T_RES_ACK;                     // Return ACK
 240   1          while(( UEP2_CTRL & MASK_UEP_T_RES ) == UEP_T_RES_ACK);                       // Waiting upload complete
             -, avoid overwriting 
 241   1      }     
 242          
 243          /*******************************************************************************
 244          * Function Name  : DeviceInterrupt()
 245          * Description    : CH554USB ISR
 246          *******************************************************************************/
 247          void DeviceInterrupt( void ) interrupt INT_NO_USB using 1                           //USB ISR, Using registe
             -r 1
 248          {
 249   1          UINT8 len;      
 250   1        
 251   1          if(UIF_TRANSFER)                                                                //USB trans flag
 252   1          { 
 253   2          switch (USB_INT_ST & (MASK_UIS_TOKEN | MASK_UIS_ENDP) )     
 254   2              {     
 255   3              case UIS_TOKEN_IN | 2:                                                      // Endpoint 2 upload
 256   3            UEP2_T_LEN = 0;                                                         // Reset length
 257   3                  UEP2_CTRL = UEP2_CTRL & ~ MASK_UEP_T_RES | UEP_T_RES_NAK;               // Default return NAK
 258   3                  break;                                                                         
 259   3           case UIS_TOKEN_OUT | 2:
 260   3           {
 261   4            len = USB_RX_LEN;
 262   4            if (len > BUFFER_SIZE)
 263   4            {
 264   5              len = BUFFER_SIZE;
 265   5            }
 266   4      
 267   4            memcpy(compound_received_data, Ep2Buffer, len);
 268   4            g_data_len = len;
 269   4            g_data_ready = 1;
 270   4            // compound_process_recv_data(len);
 271   4            
 272   4            UEP2_CTRL = UEP2_CTRL & ~ MASK_UEP_R_RES | UEP_R_RES_ACK;               // Default return ACK
 273   4            
 274   4            break;
 275   4            
 276   4                                                                // Eendpoint 2 download 
 277   4                  // UEP2_CTRL = UEP2_CTRL & ~ MASK_UEP_R_RES | UEP_T_RES_NAK;              // Default return NAK
 278   4                  // break;
 279   4           }                                                                         
 280   3              case UIS_TOKEN_IN | 1:                                                      // Endpoint 1 upload
 281   3            UEP1_T_LEN = 0;                                                         // Reset length
 282   3                  UEP1_CTRL = UEP1_CTRL & ~ MASK_UEP_T_RES | UEP_T_RES_NAK;               // Default return NAK
 283   3                  FLAG = 1;                                                               // Upload complete flag
C51 COMPILER V9.54   COMPOUND                                                              12/02/2024 10:23:19 PAGE 6   

 284   3                  break;                                                                       
 285   3              case UIS_TOKEN_SETUP | 0:                                                   // SETUP packet
 286   3                  len = USB_RX_LEN;
 287   3                  if( len == (sizeof(USB_SETUP_REQ)) )
 288   3                  {
 289   4                      SetupLen = UsbSetupBuf->wLengthL;
 290   4                      if(UsbSetupBuf->wLengthH || SetupLen > 0x7F )
 291   4                      {
 292   5                          SetupLen = 0x7F;                            // Total length less than 0X7F
 293   5                      }
 294   4                      len = 0;                                                            // Default length is 0
 295   4                      if( (UsbSetupBuf->bRequestType & USB_REQ_TYP_MASK) != USB_REQ_TYP_STANDARD )
 296   4                      {
 297   5                if( (UsbSetupBuf->bRequestType == 0x21)&&(UsbSetupBuf->bRequest == HID_SET_REPORT) )
 298   5                {     
 299   6                  EnumOK = 1;                           // Class require, SET REPORT, indicate the enumerate complete             
 300   6      #if DE_PRINTF
                printf( "Init ok \r\n" );
              #endif            
 303   6                }
 304   5                if( (UsbSetupBuf->bRequestType == 0x21)&&(UsbSetupBuf->bRequest == HID_SET_IDLE) )
 305   5                {         
 306   6                  UEP0_T_LEN = 0;                                                 //Status stage complete, upload 0 da
             -ta packet, end the control trans
 307   6        //          UEP0_CTRL = bUEP_R_TOG | bUEP_T_TOG | UEP_R_RES_STALL | UEP_T_RES_STALL;
 308   6                }
 309   5                          len = 0;                                                      // Fail
 310   5                      }
 311   4              else{
 312   5                                                  // Deal with the standard require
 313   5                SetupReq = UsbSetupBuf->bRequest;
 314   5                switch( SetupReq )                                                  // Require code
 315   5                {
 316   6                case USB_GET_DESCRIPTOR:
 317   6                  switch( UsbSetupBuf->wValueH )
 318   6                  {
 319   7                  case 1:                                                         // Device descriptor          
 320   7                    pDescr = DevDesc;                                           // Write device descriptor to buffer
 321   7                    len = sizeof( DevDesc );  
 322   7                    break;  
 323   7                  case 2:                                                         // Configuration descriptor         
 324   7                    pDescr = CfgDesc;                                           // Write configuration descriptor to buf
             -fer
 325   7                    len = sizeof( CfgDesc );  
 326   7                    break;  
 327   7                  case 0x22:                                                      // HID report descriptor            
 328   7                    if( UsbSetupBuf->wIndexL == 0 )                             // Interface index 0 HID report --> keyb
             -oard
 329   7                    {           
 330   8                      pDescr = KeyRepDesc;                                    // Write to buffer
 331   8                      len = sizeof( KeyRepDesc ); 
 332   8                    } 
 333   7                    else  
 334   7                      if( UsbSetupBuf->wIndexL == 1 )                         // Interface index 1 HID report --> Composi
             -te device
 335   7                      {               
 336   8                        pDescr = ComRepDesc;                                // Write to buffer
 337   8                        len = sizeof( ComRepDesc );
 338   8                      }
 339   7                      else
 340   7                      {
 341   8                        len = 0xff;                                         // Add interface index, if required
C51 COMPILER V9.54   COMPOUND                                                              12/02/2024 10:23:19 PAGE 7   

 342   8                      }
 343   7      //              if( UsbSetupBuf->wIndexL == 0 )                         // Interface index 1 HID report --> Compos
             -ite device
 344   7      //              {               
 345   7      //                pDescr = ComRepDesc;                                // Write to buffer
 346   7      //                len = sizeof( ComRepDesc );
 347   7      //              }
 348   7      //              else
 349   7      //              {
 350   7      //                len = 0xff;                                         // Add interface index, if required
 351   7      //              }
 352   7                      break;
 353   7                  default:
 354   7                    len = 0xff;                                                 // Length equal 0 if code error
 355   7                    break;  
 356   7                  } 
 357   6                  if ( len == 0xff ){ 
 358   7                    break;                                                      // Error code, jump out the swith senten
             -ce
 359   7                  }                     
 360   6                  if ( SetupLen > len ){  
 361   7                    SetupLen = len;                                             // Limit the total length 
 362   7                  } 
 363   6                  len = SetupLen >= 8 ? 8 : SetupLen;                             // Upload this length
 364   6                  memcpy( Ep0Buffer, pDescr, len );                               // Upload data
 365   6                  SetupLen -= len;  
 366   6                  pDescr += len;  
 367   6                  break;  
 368   6                    
 369   6                case USB_SET_ADDRESS: 
 370   6                  SetupLen = UsbSetupBuf->wValueL;                                // Save the device address          
 371   6                  break;
 372   6                case USB_GET_CONFIGURATION:
 373   6          
 374   6                  Ep0Buffer[0] = UsbConfig;
 375   6                  if ( SetupLen >= 1 )
 376   6                  {
 377   7                    len = 1;
 378   7                  }         
 379   6                  break;
 380   6                case USB_SET_CONFIGURATION:
 381   6            
 382   6                  UsbConfig = UsbSetupBuf->wValueL;       
 383   6                  break;
 384   6                case 0x0A:
 385   6                  break;
 386   6                case USB_CLEAR_FEATURE:                                             //Clear Feature
 387   6            
 388   6                  if ( (UsbSetupBuf->bRequestType & USB_REQ_RECIP_MASK) == USB_REQ_RECIP_ENDP ) 
 389   6                  {
 390   7                     switch( UsbSetupBuf->wIndexL )
 391   7                     {
 392   8                      case 0x82:
 393   8                         UEP2_CTRL = UEP2_CTRL & ~ (bUEP_T_TOG | MASK_UEP_T_RES) | UEP_T_RES_NAK;
 394   8                         break;
 395   8                      case 0x81:
 396   8                         UEP1_CTRL = UEP1_CTRL & ~ (bUEP_T_TOG | MASK_UEP_T_RES) | UEP_T_RES_NAK;
 397   8                         break;
 398   8                      case 0x01:
 399   8                         UEP1_CTRL = UEP1_CTRL & ~ (bUEP_R_TOG | MASK_UEP_R_RES) | UEP_R_RES_ACK;
 400   8                         break;
 401   8                      default:
C51 COMPILER V9.54   COMPOUND                                                              12/02/2024 10:23:19 PAGE 8   

 402   8                         len = 0xFF;                                          // Error endpoint
 403   8                         break;
 404   8                    }
 405   7                   }
 406   6                  else
 407   6                  {
 408   7                    len = 0xFF;                                                 // Deal with the error endpoint
 409   7                  }
 410   6                  break;
 411   6                case USB_SET_FEATURE:                                             // Set Feature          
 412   6                  if( (UsbSetupBuf->bRequestType & 0x1F) == 0x00 )               
 413   6                  {
 414   7                    if( ( ((UINT16)UsbSetupBuf->wValueH << 8) | UsbSetupBuf->wValueL ) == 0x01 )
 415   7                    {
 416   8                      if( CfgDesc[ 7 ] & 0x20 )
 417   8                      {
 418   9                         /* Awake the device */
 419   9                      }
 420   8                      else
 421   8                      {
 422   9                        len = 0xFF;                                         // Error routing
 423   9                      }
 424   8                    }
 425   7                    else
 426   7                    {
 427   8                      len = 0xFF;                                             // Error routing
 428   8                    }
 429   7                  }
 430   6                  else 
 431   6                    if( (UsbSetupBuf->bRequestType & 0x1F) == 0x02 )            // Set endpoint
 432   6                    {
 433   7                      if( ( ((UINT16)UsbSetupBuf->wValueH << 8) | UsbSetupBuf->wValueL ) == 0x00 )
 434   7                      {
 435   8                        switch( ((UINT16)UsbSetupBuf->wIndexH << 8) | UsbSetupBuf->wIndexL )
 436   8                        {
 437   9                          case 0x82:
 438   9                            UEP2_CTRL = UEP2_CTRL & (~bUEP_T_TOG) | UEP_T_RES_STALL;/* Endpoint 2 IN STALL */
 439   9                            break;
 440   9      
 441   9                          case 0x02:
 442   9                            UEP2_CTRL = UEP2_CTRL & (~bUEP_R_TOG) | UEP_R_RES_STALL;/* Endpoint 2 OUT STALL */
 443   9                            break;
 444   9      
 445   9                          case 0x81:
 446   9                            UEP1_CTRL = UEP1_CTRL & (~bUEP_T_TOG) | UEP_T_RES_STALL;/* Endpoint 1 IN STALL */
 447   9                            break;
 448   9      
 449   9                          default:
 450   9                            len = 0xFF;                                     // Error routing
 451   9                            break;
 452   9                        }
 453   8                      }
 454   7                      else
 455   7                      {
 456   8                        len = 0xFF;                                         // Error routing
 457   8                      }
 458   7                    }
 459   6                    else
 460   6                    {
 461   7                      len = 0xFF;                                             // Error routing
 462   7                    }
 463   6                    break;
C51 COMPILER V9.54   COMPOUND                                                              12/02/2024 10:23:19 PAGE 9   

 464   6                case USB_GET_STATUS:                          // Get status
 465   6                   Ep0Buffer[0] = 0x00;
 466   6                   Ep0Buffer[1] = 0x00;
 467   6                   if ( SetupLen >= 2 )
 468   6                   {
 469   7                    len = 2;
 470   7                   }
 471   6                   else
 472   6                   {
 473   7                    len = SetupLen;
 474   7                   }
 475   6                   break;
 476   6                default:
 477   6                  len = 0xff;                                                       // Error routing
 478   6                  break;
 479   6                }
 480   5              }
 481   4                  }
 482   3                  else
 483   3                  {
 484   4                      len = 0xff;                                                             //Packet length erro
             -r
 485   4                  }
 486   3                  if(len == 0xff)
 487   3                  {
 488   4                      SetupReq = 0xFF;
 489   4       //               UEP0_CTRL = bUEP_R_TOG | bUEP_T_TOG | UEP_R_RES_STALL | UEP_T_RES_STALL;  // Control endp
             -oint should not return STALL, 
 490   4                                                    // if Send STALL, that means the device has no ability to communicate with the host
 491   4                  }
 492   3                  else if(len <= 8)                                                           // Upload the data o
             -r return the 0 data packet
 493   3                  {   
 494   4                      UEP0_T_LEN = len;   
 495   4                      UEP0_CTRL = bUEP_R_TOG | bUEP_T_TOG | UEP_R_RES_ACK | UEP_T_RES_ACK;    // Default data pack
             -et is DATA1, and return ACK
 496   4                  }   
 497   3                  else    
 498   3                  {   
 499   4                      UEP0_T_LEN = 0;                               // Upload 0 data packet, incase the host go to status stag
             -e ahead, and get fault code
 500   4                      UEP0_CTRL = bUEP_R_TOG | bUEP_T_TOG | UEP_R_RES_ACK | UEP_T_RES_ACK;    // Default data pack
             -et is DATA1, and return ACK
 501   4                  }   
 502   3                  break;    
 503   3              case UIS_TOKEN_IN | 0:                                                          // Endpoint 0 IN
 504   3                  switch(SetupReq)
 505   3                  {
 506   4                  case USB_GET_DESCRIPTOR:
 507   4                      len = SetupLen >= 8 ? 8 : SetupLen;                                     // Current length
 508   4                      memcpy( Ep0Buffer, pDescr, len );                                       // Upload the data
 509   4                      SetupLen -= len;
 510   4                      pDescr += len;
 511   4                      UEP0_T_LEN = len;
 512   4                      UEP0_CTRL ^= bUEP_T_TOG;                                                //Toggle Sysc flag 
 513   4                      break;
 514   4                  case USB_SET_ADDRESS:
 515   4                      USB_DEV_AD = USB_DEV_AD & bUDA_GP_BIT | SetupLen;
 516   4                      UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_NAK;
 517   4                      break;
 518   4                  default:
 519   4      //                UEP0_T_LEN = 0;                                                         //Status stage com
C51 COMPILER V9.54   COMPOUND                                                              12/02/2024 10:23:19 PAGE 10  

             -plete, upload 0 data packet, end the control trans
 520   4      //                UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_NAK;    
 521   4                      break;
 522   4                  }
 523   3            if(len == 0xff)
 524   3            {
 525   4              UEP0_T_LEN = 0;                                                         //Status stage complete, upload 
             -0 data packet, end the control trans
 526   4                      UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_NAK;    
 527   4            }
 528   3                  break;
 529   3              case UIS_TOKEN_OUT | 0:                               // Endpoint 0 OUT
 530   3                  len = USB_RX_LEN;
 531   3                  if( SetupReq == 0x09 )
 532   3                  {
 533   4                      if( Ep0Buffer[0] )
 534   4                      {
 535   5      #if DE_PRINTF
                                  printf("Light on Num Lock LED!\n");
              #endif
 538   5                      }
 539   4                      else if( Ep0Buffer[0] == 0)
 540   4                      {
 541   5      #if DE_PRINTF
                                  printf("Light off Num Lock LED!\n");
              #endif
 544   5                      }
 545   4                  }
 546   3                  UEP0_T_LEN = 0;                                 // Upload 0 data packet, incase the host go to status stage a
             -head, and get fault code
 547   3                  UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_ACK;                    // Default data packet is DATA1, and retur
             -n ACK
 548   3                  break;
 549   3              default:
 550   3                  break;
 551   3              }
 552   2              UIF_TRANSFER = 0;                                                               // Reset the trans i
             -nterrupt
 553   2          }
 554   1          if( UIF_BUS_RST )                                                                   // Device mode Bus 
             -reset
 555   1          {
 556   2              UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_NAK;
 557   2              UEP1_CTRL = bUEP_AUTO_TOG | UEP_R_RES_ACK;
 558   2              UEP2_CTRL = bUEP_AUTO_TOG | UEP_R_RES_ACK | UEP_T_RES_NAK;
 559   2              USB_DEV_AD = 0x00;
 560   2              UIF_SUSPEND = 0;
 561   2              UIF_TRANSFER = 0;
 562   2              UIF_BUS_RST = 0;                                                                // Reset Reset inter
             -rupt
 563   2          }   
 564   1          if( UIF_SUSPEND )                                                                   // USB Suspended and
             - Awake interrupt
 565   1          {   
 566   2              UIF_SUSPEND = 0;    
 567   2              if ( USB_MIS_ST & bUMS_SUSPEND )                                                // Suspended
 568   2              {   
 569   3      #ifdef DEBUG    
                          printf( "Enter LPM\r\n" );                                                  // Enter LPM flag fo
             -r debug
              #endif
 572   3                  while ( XBUS_AUX & bUART0_TX )
C51 COMPILER V9.54   COMPOUND                                                              12/02/2024 10:23:19 PAGE 11  

 573   3                  {
 574   4            
 575   4                      ;                                       // Waiting send complete ...
 576   4                  }   
 577   3                  SAFE_MOD = 0x55;    
 578   3                  SAFE_MOD = 0xAA;    
 579   3                  WAKE_CTRL = bWAK_BY_USB | bWAK_RXD0_LO;                                     // Action on USB Bus,
             - or RXD0, will awake the device
 580   3                  PCON |= PD;                                                                 // LPM
 581   3                  SAFE_MOD = 0x55;    
 582   3                  SAFE_MOD = 0xAA;    
 583   3                  WAKE_CTRL = 0x00;   
 584   3              }   
 585   2          }   
 586   1          else {                                                                              // Unexpected interr
             -upt
 587   2              USB_INT_FG = 0xFF;                                                              // Reset the interru
             -pt
 588   2          }
 589   1      }
 590          
 591          /*******************************************************************************
 592          * Function Name  : static SendKey( char *p)
 593          * Description    : ASCII to key code
 594          * Input          : char *p
 595          * Output         : None
 596          * Return         : None
 597          *******************************************************************************/
 598          
 599          static void SendKey ( char *p )
 600          {
 601   1      
 602   1        char c = *p;
 603   1          
 604   1        if( (c >= 'a') && (c <= 'z' )){
 605   2          c = c - 'a' + 'A';
 606   2        }
 607   1        
 608   1        if( (c >= 'A') && (c <= 'Z' )){
 609   2          HIDKey[2] = c - 'A' + 4;
 610   2        }
 611   1        else
 612   1          if( c >= '1' && c <= '9' )
 613   1            HIDKey[2] = c - '1' + 0X1E;
 614   1          else
 615   1          {
 616   2          switch ( c ){
 617   3            case '`' :
 618   3              HIDKey[0] = 0X08;
 619   3              HIDKey[2] = 0X15;
 620   3              break;
 621   3            case '\\':
 622   3              HIDKey[2] = 0x31;
 623   3              break;
 624   3            case ' ':
 625   3              HIDKey[2] = L_SHIFT;
 626   3              break;
 627   3            case '\r':
 628   3              HIDKey[2] = ENTER;
 629   3              break;
 630   3            case ':':
 631   3              HIDKey[0] = 0x02;
C51 COMPILER V9.54   COMPOUND                                                              12/02/2024 10:23:19 PAGE 12  

 632   3              HIDKey[2] = 0x33;
 633   3              break;
 634   3            case '+':
 635   3              HIDKey[0] = 0x000;
 636   3              HIDKey[2] = 0x57;
 637   3              break;
 638   3            case '_':
 639   3              HIDKey[0] = 0X02;
 640   3              HIDKey[2] = 0X2D;
 641   3              break;
 642   3            case '/':
 643   3              HIDKey[0] = L_CTL + L_ALT;
 644   3              HIDKey[2] = 0X16;
 645   3              break;
 646   3            case '0':
 647   3              HIDKey[2] = 0X27;
 648   3              break;
 649   3            case '.':
 650   3              HIDKey[2] = 0X37;
 651   3              break;
 652   3            case '~':
 653   3              HIDKey[0] = L_ALT;
 654   3              HIDKey[2] = 0X05;
 655   3              break;
 656   3            case '!':
 657   3              HIDKey[0] = L_ALT;
 658   3              HIDKey[2] = 0X08;
 659   3              break;
 660   3            default:
 661   3              break;
 662   3          }
 663   2        }
 664   1        
 665   1        mDelaymS( 20 );                                       //emulate the press down and pop up
 666   1        while(FLAG == 0);                                                           // Upload the key
 667   1        Enp1IntIn();            
 668   1        while(FLAG == 0);                                             
 669   1        mDelaymS( 20 );
 670   1        HIDKey[0] = 0X00;                 
 671   1        HIDKey[2] = 0X00;                                                             // Reset the key
 672   1        while(FLAG == 0);                                                       
 673   1        Enp1IntIn();      
 674   1        while(FLAG == 0); 
 675   1      }
 676          
 677          /*******************************************************************************
 678          * Function Name  : static void UploadData(void)
 679          * Description    : Upload the HID code
 680          * Input          : None
 681          * Output         : None
 682          * Return         : None
 683          *******************************************************************************/
 684          static void UploadData(void)
 685          {
 686   1        UINT8 i;
 687   1        for( i = 1; i < 64 ;i ++ )
 688   1          HIDCom[i] += rand();
 689   1      }
 690          /*******************************************************************************
 691          * Function Name  : extern HIDValueHandle( void )
 692          * Description    : Upload the HID code
 693          * Input          : None
C51 COMPILER V9.54   COMPOUND                                                              12/02/2024 10:23:19 PAGE 13  

 694          * Output         : None
 695          * Return         : None
 696          *******************************************************************************/
 697          extern void HIDValueHandle( void )
 698          {
 699   1        static UINT8 rotateFlag = 0;                                // When upload keys complete, upload EP2 data
 700   1        UINT16 KeyData = TouchKeyButton;
 701   1        if(TKEY_CTRL&bTKC_IF)                                       //query key
 702   1        {
 703   2           KeyData = TKEY_DAT;                                      //
 704   2      #ifdef DE_PRINTF
 705   2           printf("B.=  %04x\n",KeyData&0x7FFF);    
 706   2      #endif
 707   2        }   
 708   1        if (rotateFlag &&(KeyData < (TouchKeyButton-100)))          //100 灵敏度调节          
 709   1        {
 710   2          HIDCom[0] += 0x01;  
 711   2          UploadData();
 712   2      
 713   2          Enp2IntIn();  
 714   2        }     
 715   1        else if(rotateFlag == 0)
 716   1        {       
 717   2              SendKey(pStr);                                         // Upload path
 718   2          pStr++; 
 719   2          if(*pStr == '\0')     
 720   2          {
 721   3            SendKey( "~" );                                      // Upload ALT+B
 722   3            mDelaymS( 200 );  
 723   3            rotateFlag = 1;
 724   3          }   
 725   2        } 
 726   1      
 727   1      }
 728          
 729          /**************************** END *************************************/
 730          
 731          void usb_send_key (char *p)
 732          {
 733   1      
 734   1        char c = *p;
 735   1          
 736   1        if( (c >= 'a') && (c <= 'z' )){
 737   2          c = c - 'a' + 'A';
 738   2        }
 739   1        
 740   1        if( (c >= 'A') && (c <= 'Z' )){
 741   2          HIDKey[2] = c - 'A' + 4;
 742   2        }
 743   1        else
 744   1          if( c >= '1' && c <= '9' )
 745   1            HIDKey[2] = c - '1' + 0X1E;
 746   1          else
 747   1          {
 748   2          switch ( c ){
 749   3            case '#':     /* f7 key */
 750   3              HIDKey[0] = 0x00;
 751   3              HIDKey[2] = 0x40;
 752   3              break;
 753   3      
 754   3            case '`' :
 755   3              HIDKey[0] = 0X08;
C51 COMPILER V9.54   COMPOUND                                                              12/02/2024 10:23:19 PAGE 14  

 756   3              HIDKey[2] = 0X15;
 757   3              break;
 758   3            case '\\':
 759   3              HIDKey[2] = 0x31;
 760   3              break;
 761   3            case ' ':
 762   3              HIDKey[2] = L_SHIFT;
 763   3              break;
 764   3            case '\r':
 765   3              HIDKey[2] = ENTER;
 766   3              break;
 767   3            case ':':
 768   3              HIDKey[0] = 0x02;
 769   3              HIDKey[2] = 0x33;
 770   3              break;
 771   3            case '+':
 772   3              HIDKey[0] = 0x000;
 773   3              HIDKey[2] = 0x57;
 774   3              break;
 775   3            case '_':
 776   3              HIDKey[0] = 0X02;
 777   3              HIDKey[2] = 0X2D;
 778   3              break;
 779   3            case '/':
 780   3              HIDKey[0] = L_CTL + L_ALT;
 781   3              HIDKey[2] = 0X16;
 782   3              break;
 783   3            case '0':
 784   3              HIDKey[2] = 0X27;
 785   3              break;
 786   3            case '.':
 787   3              HIDKey[2] = 0X37;
 788   3              break;
 789   3            case '~':
 790   3              HIDKey[0] = L_ALT;
 791   3              HIDKey[2] = 0X05;
 792   3              break;
 793   3            case '!':
 794   3              HIDKey[0] = L_ALT;
 795   3              HIDKey[2] = 0X08;
 796   3              break;
 797   3            default:
 798   3              break;
 799   3          }
 800   2        }
 801   1        
 802   1        mDelaymS( 20 );                                       //emulate the press down and pop up
 803   1        while(FLAG == 0);                                                           // Upload the key
 804   1        Enp1IntIn();            
 805   1        while(FLAG == 0);                                             
 806   1        mDelaymS( 20 );
 807   1        HIDKey[0] = 0X00;                 
 808   1        HIDKey[2] = 0X00;                                                             // Reset the key
 809   1        while(FLAG == 0);                                                       
 810   1        Enp1IntIn();      
 811   1        while(FLAG == 0); 
 812   1      }
 813          
 814          /**
 815           * @brief 计算从compound_data[1]开始的len - 1个字节的校验和
 816           * 
 817           * @param compound_data 
C51 COMPILER V9.54   COMPOUND                                                              12/02/2024 10:23:19 PAGE 15  

 818           * @param len 这里的len指的是从compound_data[2]中提取的长度值
 819           * @return UINT8 
 820           */
 821          UINT8 usb_calculate_checksum(UINT8 *compound_data, UINT8 len)
 822          {
 823   1        UINT8 checksum = 0;
 824   1        UINT8 i;
 825   1      
 826   1        for (i = 1; i < len; i++)
 827   1        {
 828   2          checksum += compound_data[i];
 829   2        }
 830   1      
 831   1        return checksum;
 832   1      }
 833          
 834          UINT8 usb_check_valid_packet(UINT8 *compound_data, UINT8 len)
 835          {
 836   1        /* 注意：接收到的数据compound_data[0]是固定的，0x00，这一位不考虑；实际判断从compound_data[1]开始考虑 */
 837   1      
 838   1        /* 协议格式是 帧头（1 byte）+ 长度（1 byte）(计算的是从帧头到校验和的长度（包括）) + OPCODE (1 byte) + DA
             -TA（不固定） + Checksum (1 byte) */
 839   1        /* 例如：0xAA 0x04 0x01 0x0A  */
 840   1        /* 帧头是0xAA，长度是0x04，OPCODE是0x01，没有DATA，checksum是0XAA + 0x04 + 0x01 = 0xB0 */
 841   1        /* 判断缓冲区接收到的数据是否是一个合法的数据包 */
 842   1      
 843   1        /* 判断流程：1. 判断compound_data[1]是否是一个合法的帧头0xAA */
 844   1        /*      2. 如果是一个合法的帧头，紧接着从compound_data[2]提取这个字节的长度 */
 845   1        /*      3. 根据协议格式计算得到checksum是位于compound_data[x]的x是多少 */
 846   1        /*      4. 再计算这包数据的checksum，与协议里面的checksum大小是否一致：如果一直，那就进入判断OPCODE的环节 *
             -/
 847   1      
 848   1        UINT8 expected_checksum = 0;
 849   1        UINT8 recved_checksum = 0;
 850   1        UINT8 length = 0;
 851   1      
 852   1        if (compound_data[1] != 0xAA)
 853   1        {
 854   2          return 0;
 855   2        }
 856   1      
 857   1        length = compound_data[2];
 858   1      
 859   1        expected_checksum = usb_calculate_checksum(compound_data, length);
 860   1        recved_checksum = compound_data[length];
 861   1        if (expected_checksum != recved_checksum)
 862   1        {
 863   2          return 0;
 864   2        }
 865   1      
 866   1        return 1;
 867   1      
 868   1      }
*** WARNING C280 IN LINE 834 OF Compound.C: 'len': unreferenced local variable
 869          
 870          
 871          // UINT8 usb_check_heartbeat_packet(UINT8 *compound_data, UINT8 len)
 872          // {
 873          
 874          //  UINT8 i = 0;
 875          //  if (compound_data[0] == 0x00 && compound_data[1] == 0x01)
 876          //  {
C51 COMPILER V9.54   COMPOUND                                                              12/02/2024 10:23:19 PAGE 16  

 877          //    ;
 878          //  }
 879          
 880            // UINT8 i;
 881              // // Iterate through the data buffer
 882              // for (i = 0; i < len; i++)
 883              // {
 884              //     if (compound_data[i] == 0xAA)  // Check if any byte equals 0xAA
 885              //     {
 886              //         return 1;  // Found 0xAA, return 1
 887              //     }
 888              // }
 889              // return 0;  // If no 0xAA is found, return 0
 890          //    UINT8 checksum = 0;
 891          //    UINT8 i;
 892          //    
 893          //    if (len != 10)
 894          //    {
 895          //        return 0;
 896          //    }
 897          //    if (compound_data[0] != PACKET_HEADER)
 898          //    {
 899          //        return 0;
 900          //    }
 901          //    if (compound_data[1] != PACKET_OPCODE_HEART)
 902          //    {
 903          //        return 0;
 904          //    }
 905          //    for (i = 0; i < len - 1; i++)
 906          //    {
 907          //        checksum += compound_data[i];
 908          //    }
 909          //    if (checksum != compound_data[len - 1])
 910          //    {
 911          //        return 0;
 912          //    }
 913          //    return 1;
 914          // }
 915          
 916          /**
 917           * @brief 
 918           * 
 919           * @param len 
 920           */
 921          void compound_process_recv_data(UINT8 len)
 922          {
 923   1        /* 响应数据包格式 */
 924   1        /* compound_response_data[0] =  0x01            1byte                       */
 925   1        /* compound_response_data[1] =  PACKET_HEADER         1byte                         */
 926   1        /* compound_response_data[2] =  LENGTH            1byte                       */
 927   1        /* compound_response_data[3] =  OPCODE            1byte                       */
 928   1        /* compound_response_data[4] =  ERROCDE           1byte                       */
 929   1        /* compound_response_data[5 ~ x] =  DATA            不固定，根据OPCODE不同，DATA内容不同            */
 930   1        /* compound_response_data[x + 1] =  CHECKSUM        1byte                       */
 931   1      
 932   1        if (usb_check_valid_packet(compound_received_data, len))  // 合法数据包
 933   1        {
 934   2          // 数据包合法，继续处理
 935   2          UINT8 opcode = compound_received_data[3];
 936   2      
 937   2          switch (opcode)
 938   2          {
C51 COMPILER V9.54   COMPOUND                                                              12/02/2024 10:23:19 PAGE 17  

 939   3            case USB_OP_HEARTBEAT:
 940   3            {
 941   4              // 心跳包:心跳包的组装的data是
 942   4              //VERSION_STR[0];
 943   4                //VERSION_STR[2];
 944   4                //VERSION_STR[4];
 945   4                //DEVICE_VID_L;           
 946   4                //DEVICE_VID_H;           
 947   4                //DEVICE_PID_L;           
 948   4                //DEVICE_PID_H;
 949   4              // ERRCODE = 0x00
 950   4      
 951   4              // 1. 业务逻辑，处理心跳包功能
 952   4      
 953   4              UINT8 checksum = 0;
 954   4              UINT8 length =  12;
 955   4              UINT8 i = 0;
 956   4      
 957   4              g_compound_heartbeat_timer = 0;
 958   4              g_compound_heartbeat_flag = 1;
 959   4              if (!first_hb_flag)
 960   4              {
 961   5                first_hb_flag = 1;
 962   5                timer0_register_cb(led_flash_handler);
 963   5              }
 964   4      
 965   4              // 2. 组装响应包并发送
 966   4              compound_response_data[0] = 0x01;   // 协议固定的，第一个字节得是0x01
 967   4              compound_response_data[1] = PACKET_HEADER;
 968   4              compound_response_data[2] = length;
 969   4              compound_response_data[3] = opcode;
 970   4              compound_response_data[4] = 0x00; // ERRCODE = 0x00
 971   4      
 972   4              compound_response_data[5] = VERSION_STR[0];
 973   4              compound_response_data[6] = VERSION_STR[2];
 974   4              compound_response_data[7] = VERSION_STR[4];
 975   4              compound_response_data[8] = DEVICE_VID_L;
 976   4              compound_response_data[9] = DEVICE_VID_H;
 977   4              compound_response_data[10] = DEVICE_PID_L;
 978   4              compound_response_data[11] = DEVICE_PID_H;
 979   4      
 980   4              // 计算校验和，计算[1] ~ [11]的校验和
 981   4              for (i = 1; i < 12; i++)
 982   4              {
 983   5                checksum += compound_response_data[i];
 984   5              }
 985   4              compound_response_data[12] = checksum;
 986   4      
 987   4              // 填充剩余的字节为0x00，直到64字节
 988   4              memset(&compound_response_data[13], 0, 51);  // 64 - 13 = 51
 989   4      
 990   4              // 发送数据
 991   4              memcpy(&Ep2Buffer[BUFFER_SIZE], compound_response_data, 64);  
 992   4                  UEP2_T_LEN = 64;
 993   4                  UEP2_CTRL = (UEP2_CTRL & ~MASK_UEP_T_RES) | UEP_T_RES_ACK;
 994   4      
 995   4              break;
 996   4            }
 997   3            case USB_OP_WL_LEARNMATCH:
 998   3            {
 999   4              // 学习匹配
1000   4              // 学习匹配没有data
C51 COMPILER V9.54   COMPOUND                                                              12/02/2024 10:23:19 PAGE 18  

1001   4              // ERRCODE = 0x00
1002   4      
1003   4              // 1. 业务逻辑，学习匹配无线按键控制USB键盘
1004   4              // 拉低P1^6 4s，进入学习模式，然后拉高
1005   4              // 首先考虑阻塞可不可以。如果阻塞4s，那么久不能处理其他的数据包，这会直接导致心跳包的处理失败，进而重
             -USB设备，这是不允许的
1006   4              // 所以，必须使用非阻塞方法。想法是利用原有的定时器，原来的定时器是定时10ms，那就是可以在这个主程序里
             -孀⒉峄氐骱数，然后在回调函数里面定时4s，然后就是主程序里4s后主程序里来一个全局变量置位，
1007   4              // 上位机下发学习命令，状态机接收到，立刻回复usb主机开始处理学习，然后进入学习状态：拉低P1.6 4s，然后
             -高；这个怎么通过非阻塞的方法实现呢？
1008   4      
1009   4              UINT8 checksum = 0;
1010   4              UINT8 length = 5; // header + length + opcode + ERRCODE + checksum
1011   4              UINT8 i = 0;
1012   4      
1013   4      
1014   4              if (learnmatch_state == LEARNMATCH_STATE_IDLE)
1015   4              {
1016   5                WL_LEARN_PIN = 0;
1017   5                learnmatch_state = LEARNMATCH_STATE_ACTIVE;
1018   5                g_learnmatch_timer = 0;
1019   5              }
1020   4      
1021   4              // 2. 组装响应包并发送
1022   4              compound_response_data[0] = 0x01;   // 协议固定的，第一个字节得是0x01
1023   4              compound_response_data[1] = PACKET_HEADER;
1024   4              compound_response_data[2] = length;
1025   4              compound_response_data[3] = opcode;
1026   4              compound_response_data[4] = 0x00; // ERRCODE = 0x00,表示成功
1027   4      
1028   4              for (i = 1; i < 5; i++)
1029   4              {
1030   5                checksum += compound_response_data[i];
1031   5              }
1032   4              compound_response_data[5] = checksum;
1033   4              memset(&compound_response_data[6], 0, 58);  // 64 - 6 = 58
1034   4      
1035   4              // 发送数据
1036   4              memcpy(&Ep2Buffer[BUFFER_SIZE], compound_response_data, 64);  
1037   4              UEP2_T_LEN = 64;
1038   4              UEP2_CTRL = (UEP2_CTRL & ~MASK_UEP_T_RES) | UEP_T_RES_ACK;
1039   4      
1040   4              break;
1041   4            }
1042   3            case USB_OP_WL_CLEANMATCH:
1043   3            {
1044   4              // 清空匹配
1045   4              // 清空匹配没有data
1046   4              // ERRCODE = 0x00
1047   4              // 清空匹配和学习匹配的区别是，清空匹配是拉低11s，然后拉高
1048   4              UINT8 checksum = 0;
1049   4              UINT8 length = 5; // header + length + opcode + ERRCODE + checksum
1050   4              UINT8 i = 0;
1051   4      
1052   4      
1053   4              if (cleanmatch_state == CLEANMATCH_STATE_IDLE)
1054   4              {
1055   5                WL_LEARN_PIN = 0;
1056   5                cleanmatch_state = CLEANMATCH_STATE_ACTIVE;
1057   5                g_cleanmatch_timer = 0;
1058   5              }
1059   4      
C51 COMPILER V9.54   COMPOUND                                                              12/02/2024 10:23:19 PAGE 19  

1060   4              // 2. 组装响应包并发送
1061   4              compound_response_data[0] = 0x01;   // 协议固定的，第一个字节得是0x01
1062   4              compound_response_data[1] = PACKET_HEADER;
1063   4              compound_response_data[2] = length;
1064   4              compound_response_data[3] = opcode;
1065   4              compound_response_data[4] = 0x00; // ERRCODE = 0x00,表示成功
1066   4      
1067   4              for (i = 1; i < 5; i++)
1068   4              {
1069   5                checksum += compound_response_data[i];
1070   5              }
1071   4              compound_response_data[5] = checksum;
1072   4              memset(&compound_response_data[6], 0, 58);  // 64 - 6 = 58
1073   4      
1074   4              // 发送数据
1075   4              memcpy(&Ep2Buffer[BUFFER_SIZE], compound_response_data, 64);  
1076   4              UEP2_T_LEN = 64;
1077   4              UEP2_CTRL = (UEP2_CTRL & ~MASK_UEP_T_RES) | UEP_T_RES_ACK;
1078   4      
1079   4              break;
1080   4            }
1081   3      
1082   3            default:
1083   3            {
1084   4              // 未知的OPCODE, 需要回复错误码
1085   4              // 未知的OPCODE的data是空的
1086   4              // ERRCODE = 0x01
1087   4              break;
1088   4            }
1089   3      
1090   3          }
1091   2      
1092   2        }
1093   1        else  // 非法数据包 echo模式
1094   1        {
1095   2              memcpy(compound_response_data, compound_received_data, len);
1096   2              memcpy(&Ep2Buffer[BUFFER_SIZE], compound_response_data, len);
1097   2              UEP2_T_LEN = len;
1098   2              UEP2_CTRL = (UEP2_CTRL & ~MASK_UEP_T_RES) | UEP_T_RES_ACK;
1099   2        }
1100   1      
1101   1          // UINT8 checksum = 0;
1102   1          // UINT8 i;  /* 移到函数开始处声明 */
1103   1          
1104   1      
1105   1        
1106   1          // if (usb_check_heartbeat_packet(compound_received_data, len))
1107   1          // {
1108   1        //  g_compound_heartbeat_timer = 0;
1109   1        //  g_compound_heartbeat_flag = 1;
1110   1      
1111   1          //     // compound_response_data[0] = PACKET_HEADER;
1112   1          //     // compound_response_data[1] = PACKET_OPCODE_HEART;
1113   1          //     // compound_response_data[2] = VERSION_STR[0];
1114   1          //     // compound_response_data[3] = VERSION_STR[2];
1115   1          //     // compound_response_data[4] = VERSION_STR[4];
1116   1          //     // compound_response_data[5] = DEVICE_VID_L;           
1117   1          //     // compound_response_data[6] = DEVICE_VID_H;           
1118   1          //     // compound_response_data[7] = DEVICE_PID_L;           
1119   1          //     // compound_response_data[8] = DEVICE_PID_H;           
1120   1              
1121   1          //     // for(i = 0; i < 9; i++) 
C51 COMPILER V9.54   COMPOUND                                                              12/02/2024 10:23:19 PAGE 20  

1122   1          //     // {
1123   1          //     //     checksum += compound_response_data[i];
1124   1          //     // }
1125   1          //     // compound_response_data[9] = checksum;
1126   1              
1127   1          //     // memcpy(&Ep2Buffer[BUFFER_SIZE], compound_response_data, 10);  
1128   1          //     // UEP2_T_LEN = 10;
1129   1          //     // UEP2_CTRL = (UEP2_CTRL & ~MASK_UEP_T_RES) | UEP_T_RES_ACK;
1130   1              
1131   1          //     // if (!first_hb_flag)
1132   1          //     // {
1133   1          //     //     first_hb_flag = 1;
1134   1          //     //     timer0_register_cb(led_flash_handler);
1135   1          //     // }
1136   1        //  compound_response_data[0] = 0x01;
1137   1        //  compound_response_data[1] = PACKET_HEADER;
1138   1          //     compound_response_data[2] = PACKET_OPCODE_HEART;
1139   1          //     compound_response_data[3] = VERSION_STR[0];
1140   1          //     compound_response_data[4] = VERSION_STR[2];
1141   1          //     compound_response_data[5] = VERSION_STR[4];
1142   1          //     compound_response_data[6] = DEVICE_VID_L;           
1143   1          //     compound_response_data[7] = DEVICE_VID_H;           
1144   1          //     compound_response_data[8] = DEVICE_PID_L;           
1145   1          //     compound_response_data[9] = DEVICE_PID_H;           
1146   1              
1147   1          //     for(i = 1; i < 10; i++) 
1148   1          //     {
1149   1          //         checksum += compound_response_data[i];
1150   1          //     }
1151   1          //     compound_response_data[10] = checksum;
1152   1          //     // 填充剩余的字节为0x00，直到64字节
1153   1          //     memset(&compound_response_data[11], 0, 53);  // 64 - 11 = 53 
1154   1      
1155   1          //     memcpy(&Ep2Buffer[BUFFER_SIZE], compound_response_data, 64);  
1156   1          //     UEP2_T_LEN = 64;
1157   1          //     UEP2_CTRL = (UEP2_CTRL & ~MASK_UEP_T_RES) | UEP_T_RES_ACK;
1158   1              
1159   1          //     if (!first_hb_flag)
1160   1          //     {
1161   1          //         first_hb_flag = 1;
1162   1          //         timer0_register_cb(led_flash_handler);
1163   1          //     }
1164   1          // }
1165   1          // else
1166   1          // {
1167   1          //     memcpy(compound_response_data, compound_received_data, len);
1168   1          //     memcpy(&Ep2Buffer[BUFFER_SIZE], compound_response_data, len);
1169   1          //     UEP2_T_LEN = len;
1170   1          //     UEP2_CTRL = (UEP2_CTRL & ~MASK_UEP_T_RES) | UEP_T_RES_ACK;
1171   1          // }
1172   1      }
1173          
1174          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2829    ----
   CONSTANT SIZE    =    228    ----
   XDATA SIZE       =    231      18
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
C51 COMPILER V9.54   COMPOUND                                                              12/02/2024 10:23:19 PAGE 21  

   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
